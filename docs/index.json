[{"uri":"http://spdldaemon.github.io/docs/tools/kicad/usingkicad/","title":"Using KiCad","tags":[],"description":"","content":"KiCad is pretty powerful, and as with many open-source software, can sometimes have a steep learning curve. For the purposes of use in lab, the rest of this tutorial will focus on things you might use reasonably often. The detailed information can always be found in the KiCad documentation.\nThat being said, your life will be enormously easier if you get used to some of the keyboard shortcuts for navigation.\nShortcut keys KiCad has two kinds of related but different shortcut keys: accelerator keys and hotkeys. Both are used to speed up working in KiCad by using the keyboard instead of the mouse to change commands.\nAccelerator keys Accelerator keys have the same effect as clicking on a menu or toolbar icon: the command will be entered but nothing will happen until the left mouse button is clicked. Use an accelerator key when you want to enter a command mode but do not want any immediate action.\nAccelerator keys are shown on the right side of all menu panes:\nHotkeys A hotkey is equal to an accelerator key plus a left mouse click. Using a hotkey starts the command immediately at the current cursor location. Use a hotkey to quickly change commands without interrupting your workflow.\nTo view hotkeys within any KiCad tool go to Help\r\rList Hotkeys or press Ctrl+F1:\nYou can edit the assignment of hotkeys, and import or export them, from the Preferences\r\rHotkeys Options menu.\nIn this document, keypresses are expressed with styling like this: a. If you see a, just type the \u0026ldquo;a\u0026rdquo; key on the keyboard.\n Example Consider the simple example of adding a wire in a schematic.\nTo use an accelerator key, press Shift+w to invoke the \u0026ldquo;Add wire\u0026rdquo; command (note the cursor will change). Next, left click on the desired wire start location to begin drawing the wire.\nWith a hotkey, simply press w and the wire will immediately start from the current cursor location.\nGetting Around By default, the mouse wheel zooms in and out. Holding Shift while scrolling will scroll the page up and down, while holding Ctrl will scroll left and right. Panning can also be done by holding down the middle mouse button (wheel) and dragging.\nStarting a New Project Each project in KiCad needs a dedicated directory, and has a *.pro file defining the project. To create a project, go to the KiCad man window, then select File\r\rNew\r\rProject\u0026hellip; or simply press Ctrl+N. When making the project, leave the checkbox to create a new directory ticked unless you already have a dedicated directory.\n"},{"uri":"http://spdldaemon.github.io/docs/tools/kicad/schematiccapture/","title":"Schematic Capture","tags":[],"description":"","content":"Eeschema Eeschema is KiCad\u0026rsquo;s schematic capture and annotation tool; this is where you\u0026rsquo;ll be drawing your schematics by placing components and hooking them up. If you haven\u0026rsquo;t already, start or open a project to hold the schematic.\nBefore stepping through this tutorial, download the teensy.lib symbol library from https://github.com/XenGi/teensy_library.\nSome useful shortcuts The keyboard shortcuts you\u0026rsquo;ll be using most frequently for schematics are:\n a - add a component. c - copy a component. w - wire components together. e - edit a component. v - edit component value. Esc - escape any command in progress. Ctrl+z - undo. Ctrl+s - save.  Creating a Schematic   Let’s begin by creating a schematic. Start the schematic editor Eeschema, . It is the first button from the left.\n  Click on the \u0026lsquo;Page Settings\u0026rsquo; icon on the top toolbar. Set the appropriate paper size (\u0026lsquo;A4\u0026rsquo;, \u0026lsquo;8.5x11\u0026rsquo;, etc.) and enter the Title as \u0026lsquo;Tutorial\u0026rsquo;. You will see that more information can be entered here if necessary. Click OK. This information will populate the schematic sheet at the bottom right corner. Use the mouse wheel to zoom in. Save the whole schematic: File\r\rSave\n  We will now place our first component. Click on the \u0026lsquo;Place symbol\u0026rsquo; icon in the right toolbar. You may also press the \u0026lsquo;Add Symbol\u0026rsquo; hotkey a.\n  Click on the middle of your schematic sheet. A Choose Symbol window will appear on the screen. Note that several thousand schematic symbols may be loaded, so make frequent use of search.\nWe’re going to place a resistor. Search / filter on the \u0026lsquo;R\u0026rsquo; of Resistor. You may notice the \u0026lsquo;Device\u0026rsquo; heading above the Resistor. This \u0026lsquo;Device\u0026rsquo; heading is the name of the library where the component is located, which is quite a generic and useful library.\n  Once you use a symbol, it will be listed at the top with other recently used symbols, making filling in passives easier.\n  Double click on it. This will close the Choose Symbol window. Place the component in the schematic sheet by clicking where you want it to be.\n  Try to hover the mouse over the component \u0026lsquo;R\u0026rsquo; and press r. The component should rotate. You do not need to actually click on the component to rotate it.\n  Sometimes, if your mouse is also over something else, a menu will appear. You will see the Clarify Selection menu often in KiCad; it allows working on objects that are on top of each other. In this case, tell KiCad you want to perform the action on the \u0026lsquo;Symbol …​R…​\u0026rsquo; if the menu appears.\n Right click in the middle of the component and select Properties\r\rEdit Value. You can achieve the same result by hovering over the component and pressing v. Alternatively, e will take you to the more general Properties window. Notice how the right-click menu below shows the hotkeys for all available actions.  The Edit Value Field window will appear. Replace the current value \u0026lsquo;R\u0026rsquo; with \u0026lsquo;1k\u0026rsquo;. Click OK  Do not change the Reference field (R?), this will be done automatically later on. The value above the resistor should now be \u0026lsquo;1k\u0026rsquo;.\n  To place another resistor, simply click where you want the resistor to appear. The symbol selection window will appear again.\n  The resistor you previously chose is now in your history list, appearing as \u0026lsquo;R\u0026rsquo;. Click OK and place the component.\n  In case you make a mistake and want to delete a component, right click on the component and click \u0026lsquo;Delete\u0026rsquo;. This will remove the component from the schematic. Alternatively, you can hover over the component you want to delete and press Del.\n  You can also duplicate a component already on your schematic sheet by hovering over it and pressing c. Click where you want to place the new duplicated component.\n  Right click on the second resistor. Select \u0026lsquo;Drag\u0026rsquo;. Reposition the component and left click to drop. The same functionality can be achieved by hovering over the component and by pressing g. r will rotate the component while x and y will flip it about its x- or y-axis.\n  Right-Click  Move or m is also a valuable option for moving anything around, but it is better to use this only for component labels and components yet to be connected. This is because Drag keeps wire connections to the component attached while moving, while Move simply moves the components, leaving the wires behind. Both can be useful, but Drag is more often what you want.\n  Edit the second resistor by hovering over it and pressing v. Replace \u0026lsquo;R\u0026rsquo; with \u0026lsquo;100\u0026rsquo;. You can undo any of your editing actions with Ctrl+Z.\n  Change the grid size. You have probably noticed that on the schematic sheet all components are snapped onto a large pitch grid. You can easily change the size of the grid by Right-Click\r\rGrid.\n  In general, it is recommended to use a grid of 50.0 mils for the schematic sheet.\n  We are going to add a Teensy to our circuit, which does not have a symbol natively in KiCad. Copy teensy.lib into the KiCad project folder. In the Eeschema menu, choose Preferences\r\rManage Symbol Libraries. In the Symbol Libraries window you can see two tabs: Global Libraries and Project Specific Libraries. Each one has one sym-lib-table file. For a library (.lib file) to be available it must be in one of those sym-lib-table files. If you have a library file in your file system and it’s not yet available, you can add it to either one of the sym-lib-table files. We will now add the Teensy library.\n  Select the Project Specific table. Click the Browse Libraries\u0026hellip; button below the table. Since you placed the library in the project folder, you should be able to choose and add the teensy.lib library and close the window. It will be added to the end of of the list. If you wish you can click its nickname and change it, but \u0026lsquo;teensy\u0026rsquo; is fine for now. Close the Symbol Libraries window with OK.\n  Repeat the add-component steps, however this time select the \u0026lsquo;teensy\u0026rsquo; library instead of the \u0026lsquo;Device\u0026rsquo; library and pick the \u0026lsquo;Teensy-LC\u0026rsquo; component.\n  Hover the mouse over the microcontroller component. Notice that x and y again flip the component. Keep the symbol mirrored around the Y axis so that pins 5 and 6 (3_RX1_PWM_Touch and 4_TX1_PWM_Touch) point to the right.\n  Repeat the add-component steps, this time choosing the \u0026lsquo;Device\u0026rsquo; library and picking the \u0026lsquo;LED\u0026rsquo; component from it.\n  Add another component, this time Conn_01x03_Male. This is a generic 3-pin connector.\n  Organize all components on your schematic sheet as shown below.\n  The component identifier \u0026lsquo;J?\u0026rsquo; will appear above the Conn_01x03_Male label. If you want to change its position, right click on \u0026lsquo;J?\u0026rsquo; and click on \u0026lsquo;Move Field\u0026rsquo; (equivalent to m). It might be helpful to zoom in before/while doing this. Reposition \u0026lsquo;J?\u0026rsquo; under the component as shown below. Labels can be moved around as many times as you please.   It is time to place the power and ground symbols. Click on the \u0026lsquo;Place power port\u0026rsquo; button on the right toolbar. Alternatively, press p. In the component selection window, scroll down and select \u0026lsquo;VCC\u0026rsquo; from the \u0026lsquo;power\u0026rsquo; library. Click OK.\n  Click above the pin of the 1\u0026thinsp;k\u0026Omega; resistor to place the VCC part. Click on the area above and to the left of the Teensy. In the \u0026lsquo;Component Selection history\u0026rsquo; section select \u0026lsquo;VCC\u0026rsquo; and place another to the left of the microcontroller. Repeat the add process again and place a VCC part above pin 1 of the connector. Move references and values out of the way if needed.\n  Repeat the add power symbol steps but this time select the GND part. Place a GND part under pin 3 of the connector. Place another GND symbol below and to the left of the microcontroller. Your schematic should now look something like this:\n  Next, we will wire all our components. Click on the \u0026lsquo;Place wire\u0026rsquo; icon on the right toolbar.  Be careful not to pick \u0026lsquo;Place bus\u0026rsquo;, which appears directly beneath this button but has thicker lines and is blue. For more on how to use bus connections refer to the full KiCad Documentation.\n Click on the little circle at the end of pin 5 of the microcontroller and then click on the little circle on pin 1 of the LED. Click once when you are drawing the wire to create a corner. You can zoom in while you are placing the connection.  If you want to reposition wired components, it is important to use g (to grab) and not m (to move). Using grab will keep the wires connected.\n Repeat this process and wire up all the other components as shown below. To terminate a wire just double-click. When wiring up the VCC and GND symbols, the wire should touch the bottom of the VCC symbol and the middle top of the GND symbol. See the screenshot below.   We will now consider an alternative way of making a connection using labels. Pick a net labelling tool by clicking on the \u0026lsquo;Place net label\u0026rsquo; icon on the right toolbar. You can also use l.\n  Click the wire connected to the resistor which we connected to pin 6 of the microcontroller. Name this label \u0026lsquo;INPUT\u0026rsquo;. The label is still an independent item which you can for example move, rotate and delete. The small anchor rectangle of the label must be exactly on a wire or a pin for the label to take effect.\n  Follow the same procedure and place another label on the wire to pin 2 of the connector. Also name it \u0026lsquo;INPUT\u0026rsquo;. The two labels, having the same name, create an invisible connection between pin 2 of the connector and the 100\u0026thinsp;\u0026Omega; resistor. This is a useful technique when connecting wires in a complex design where drawing the lines would make the whole schematic messier. To place a label you do not necessarily need a wire, you can simply attach the label to a pin.\n  Labels can also be used to simply label wires for informative purposes. Place a label on pin 5 of the Teensy. Enter the name \u0026lsquo;uCtoLED\u0026rsquo;. Name the wire between the resistor and the LED as \u0026lsquo;LEDtoR\u0026rsquo;.\n  You do not have to label the VCC and GND lines because the labels are implied from the power objects they are connected to.\n  Below you can see what the final result should look like.\n   Sometimes it is good to write comments here and there. To add comments on the schematic use the \u0026lsquo;Place text\u0026rsquo; icon on the right toolbar.\n  All components now need to have unique identifiers, so let\u0026rsquo;s rename all of those components still named \u0026lsquo;R?\u0026rsquo; or \u0026lsquo;J?\u0026rsquo;. Identifier assignation can be done automatically by clicking on the \u0026lsquo;Annotate schematic symbols\u0026rsquo; icon ~annotate symbols icon on the top toolbar.\n  In the Annotate Schematic window, select \u0026lsquo;Use the entire schematic\u0026rsquo; and click on the \u0026lsquo;Annotate\u0026rsquo; button. Click \u0026lsquo;Close\u0026rsquo;. Notice how all the \u0026lsquo;?\u0026rsquo; have been replaced with numbers. Each identifier is now unique. In our example, they have been named \u0026lsquo;R1\u0026rsquo;, \u0026lsquo;R2\u0026rsquo;, \u0026lsquo;U1\u0026rsquo;, \u0026lsquo;D1\u0026rsquo; and \u0026lsquo;J1\u0026rsquo;.\n  If you\u0026rsquo;re just capturing the schematic for documentation purposes, this schematic is now finished. Hit Ctrl+s to save, and you\u0026rsquo;re done! If you want a PDF version, either select \u0026lsquo;Print\u0026rsquo; and print to a pdf printer, or select \u0026lsquo;Plot\u0026rsquo; and set the output format to PDF.\n  Additional steps to run ERC KiCad can also run an electrical rules check (ERC) to catch obvious mistakes; to do this, we need to make some more annotations to tell KiCad what we\u0026rsquo;re doing.\n  First deal with unconnected wires. Any pin or wire that is not connected will generate a warning when checked by KiCad. To avoid these warnings you can either instruct the program that the unconnected wires are deliberate or manually flag each unconnected wire or pin as unconnected.\n  Click on the \u0026lsquo;Place no connection flag\u0026rsquo; icon on the right toolbar. Click on the unconnected pins. An X will appear to signify that the lack of a wire connection is intentional.\n  It is now necessary to add a \u0026lsquo;Power Flag\u0026rsquo; to indicate to KiCad that power comes in from somewhere. Press a and search for \u0026lsquo;PWR_FLAG\u0026rsquo; which is in \u0026lsquo;power\u0026rsquo; library. Place two of them. Connect them to a GND pin and to VCC as shown below.\n  We can now check our schematic for errors. Click on the \u0026lsquo;Perform electrical rules check\u0026rsquo; icon on the top toolbar. Click on the \u0026lsquo;Run\u0026rsquo; button. A report informing you of any errors or warnings such as disconnected wires is generated. You should have 0 Errors and 0 Warnings. In case of errors or warnings, a small green arrow will appear on the schematic in the position where the error or the warning is located. Check \u0026lsquo;Create ERC file report\u0026rsquo; and press the \u0026lsquo;Run\u0026rsquo; button again to receive more information about the errors.  "},{"uri":"http://spdldaemon.github.io/docs/tools/onshape/","title":"Onshape","tags":[],"description":"","content":"Why Onshape? Onshape is a full-cloud parametric CAD system that runs in your browser. This means that your document is stored in the cloud, and if you\u0026rsquo;re working on a group project, everyone edits a single copy of the document, real-time. No more sending one person off to do all the CAD or dealing with whether \u0026ldquo;Version 1 Final Actual Final\u0026rdquo; or \u0026ldquo;Final Version 1\u0026rdquo; is the more recent copy.\nAlso, since a lot of CAD in the SPDL context is laser-cut assemblies, Onshape\u0026rsquo;s scripting functionality allows for custom features that make CAD for laser-cut assemblies a snap.\nOnshape currently offers all professional features except release management for free with a .edu email address.\nGetting Set Up First, sign up for an educational account using your Stanford .edu email address. Note that as of Fall 2019, the education subscription expires after 365 days, at which point all your Education-tagged documents become read-only. You can sign up again using the same form to add another year of the Education plan as long as you continue being a student.\nIf you\u0026rsquo;re used to Solidworks, Inventor, or some other CAD software, you can change Onshape\u0026rsquo;s input preferences to match what you\u0026rsquo;re used to. Once logged in, go to your account preferences page, and under \u0026ldquo;View manipulation\u0026rdquo; choose the option for the software you\u0026rsquo;re most familiar with.\nOnshape has an Introduction to CAD as well as more in-depth courses on CAD and data management to help you get up to speed on using the software.\nIf you\u0026rsquo;re going to be making a lot of laser-cut parts, you\u0026rsquo;ll want to add the set of custom features I wrote to help do that:\n Laser Joint Computes and generates finger joints between intersecting plates. T-Slot Joint Creates bolted edge connections between plates. Kerf Compensation Compensates geometry when cutting with software that does not compensate toolpaths for the laser kerf (all laser cutters on campus, at least). Auto Layout Automatically lays out parts for cutting using a rectangular bin-packing algorithm.  To add these features to your toolbar, open an Onshape document, and click the icon at the right end of your toolbar. In the \u0026ldquo;Search documents or paste URL\u0026rdquo; field, paste each of the above URLs, and add the features to the toolbar.\nEach of the links above also points to a PDF containing documentation for each feature.\nUnless you\u0026rsquo;re very interested in writing your own custom code, don\u0026rsquo;t \u0026ldquo;Make a copy\u0026rdquo; from the links above; that means you won\u0026rsquo;t get updates to the features if and when I make them.\n Using Onshape to make a Laser-cut Thing As an example, we\u0026rsquo;ll go through the process of getting the basic shape of my ME218 project, Big Game Hunting, drawn up in Onshape and then exported to cut on a laser.\nCAD the Base Geometry We\u0026rsquo;ll start by creating the solid model of the parts we want, before setting up to cut them on a laser.\nSo What is a Part Studio Anyway? If you totally skipped all the tutorials above1, here\u0026rsquo;s the quick summary of what a \u0026ldquo;Part Studio\u0026rdquo; is.\nWhere most CAD programs have a single part being modeled in a single file, and use assemblies for the physical interfacing of parts and motion studies, this often means that multiple parts that are inherently related in geometry must be modeled separately, or with in-context assembly features, which can reduce robustness of the modeling.\nOnshape uses Part Studios to model parts. Each Part Studio can (and often does) have several parts which are closely related in form or function. This allows, for example, modeling two flanges and a bolt circle using a single Hole feature, so that any updates automatically occur on both sides of the bolted joint. Note that parts cannot move in a Part Studio; motion studies should be done in Assemblies. This link is one-way: parts will maintain their positions in the Part Studio as modeled even if the assembly is moved.\nDifferent groups of parts which do not need to be modeled together can be split into different part studios to speed up regeneration time, and then the subassemblies can be test-fit in an Assembly.\nFor more complicated geometries, it is also possible to model parts in-context with reference to a particular state of an Assembly. Typically, this will be when a part\u0026rsquo;s geometry depends on the motion of the assembly. For parts without complex constraints, try to keep your modeling in Part Studios.\nVariables Especially when modeling geometry that has specified dimensions, like the board thicknesses for your laser cut parts, it is extremely helpful to first define variables that you can then reference later throughout the design. If you then need to go through and change dimensions because your board is 6\u0026thinsp;mm instead of 0.25\u0026thinsp;in, this will make that fix much much easier for you later.\nThe feature for defining variables is on the toolbar as .\nIf you\u0026rsquo;re ever lost as to where a feature is located, pressing Alt+c will open a search dialog. The feature location will also be highlighted on the toolbar.\n Define one constant for thick plates (e.g. 6\u0026thinsp;mm), and one for thin plates (e.g. 3\u0026thinsp;mm). This should look something like this:\nSketch and Extrude The Base Click and start a sketch on the top plane. Alternatively, Shift+s is the shortcut for starting a sketch. Drag a center-point rectangle (Shortcut: r) from the origin. Dimension it (Shortcut: d) to 18 by 18 inches, and accept the sketch.\n\r\r\r\rWe\u0026rsquo;ll now turn the sketch into solid geometry. Click \u0026ldquo;Extrude\u0026rdquo; (Shortcut: Shift+e). For \u0026ldquo;faces and sketch regions\u0026rdquo;, simply choose the sketch itself from the feature tree. For the depth, type in \u0026ldquo;#duron_thick\u0026rdquo; to reference the variable you created earlier.\n\r\r\r\rSketch the Sides Start a sketch on the right face of the base you just extruded, and sketch and dimension the outline of the box. Extrude, again selecting the sketch itself as the object. Make sure that the extrusion mode is set to \u0026ldquo;new\u0026rdquo; to create a new part, and not \u0026ldquo;add,\u0026rdquo; which would merge the new extrusion with the base. You should now have two parts that look like this:\nChoose the mirror feature from the toolbar, and mirror the side plate across the right plane, again using the \u0026ldquo;new\u0026rdquo; option rather than \u0026ldquo;add.\u0026rdquo;\n\r\r\r\rGenerally, you want to avoid mirroring identical parts, instead modeling them once and then making copies in the assembly. In this particular case, mirroring in the part studio helps with the laser-cutting workflow. On an actual project your left and right sides will also likely be different.\n Sketch and Extrude The Cross Members You can extrude multiple disjoint regions as part of a single sketch, and they\u0026rsquo;ll all become parts. So for the cross members, we can do everything as a single sketch to define geometry, and then extrude regions from the same sketch in multiple operations.\nMake a new sketch on the outside face of one of the side plates. Sketch the vertical and horizontal components using corner rectangles (Shortcut: r). For the two pieces along the angled line, sketch a couple of corner rectangles, and select the bottom horizontal line. This should highlight the constraints for that line. Delete the horizontal constraint, and then add a coincident constraint between the top line and the edge of the plate.\nAdd equality constraints to the thickness dimensions of all the rectangles, and then dimension one to be #duron_thick.\nExtrude non-intersecting plates across the volume, using the \u0026ldquo;terminate at face\u0026rdquo; option to go to the outside face of the other side plate. I did the front, back, top spar, and one of the middle spars in one extrude, and the remaining parts in another operation. You\u0026rsquo;ll have to un-hide the sketch after the first extrude to be able to select different regions from it the second time.\n  Creating the cross members. Sketch includes all geometry extruded along the right plane. All parts are extruded as two non-overlapping sets.\n  Sketch and Extrude Facing Plates These plates will end up covering the insides of the box. For each, sketch and extrude a plate of thickness #duron_thin. Your box should now look something like this:\nAssemble and Create Connections Assemble the Parts In this particular case, we made all mirror copies of parts in the part studio. However, for the sake of going through the process, we\u0026rsquo;ll pull the parts into an assembly.\nCreate a new assembly, and then click , then simply select the entire part studio. Click accept without clicking in the viewport to insert at the origin. Right-click the base part and click \u0026ldquo;fix\u0026rdquo;—this constrains all degrees of freedom for that part. You can now click and select all parts to create a group constraint, which fixes all degrees of freedom between parts in the group.\nIf the sides were identical geometry, here\u0026rsquo;s where you\u0026rsquo;d make multiple copies of them in the assembly.\nCreate an In-Context Part Studio This in-context part studio will allow us to make joints on the assembled components, as well as be the starting point for laying them out to cut. From the assembly, click to create a part studio from the assembly. Once in the new part studio, create a Transform feature, and copy in place all of the components from the assembly context. You can now hide the assembly context view and work with the local copies to add joints without affecting the parts in the assembly.\nThis link can be updated, but does not do so automatically. Updating the context can be done from the context menu at the top of the part studio feature tree.\nAdd T-Slot Connections for the Facing Plates We want the facing plates to be removable so you can get at the insides. One way to do this, though by no means the only, is to use bolted edge connections through the facing plates into the edge plates.\nSelect T-Slot Joint from your custom feature toolbar. Select the edge face of the side plate, and set the joint parameters so you get connections where you want them. It may be helpful to hide the facing plates so you can easily select the edges to add the joints on.\nRepeat for all four edges.\nLaser Joint Select the Laser Joint feature from your custom feature toolbar. Select Automatic mode, then drag-select all of the non-facing parts. Enable adaptive pin sizing, and set the limits appropriately. I\u0026rsquo;ve found that for most work in ME218, the other options aren\u0026rsquo;t necessary, but play around with them to get a feel for it. Leave Allowance disabled here to get a nice fit for your parts.\nNote that it\u0026rsquo;s notifying you that \u0026ldquo;Laser Joint created small disconnected components which were deleted.\u0026rdquo; This is something you might see if three2 components all intersect in the same location at odd angles; sometimes this means that small triangles will be left unconnected to anything else after the joint. Laser Joint will automatically remove anything it thinks is sufficiently small, but provides a warning in case it really matters.\nOccasionally your configurations may result in zero-thickness geometry once the joints are computed; in this case, Laser Joint will fail.\nTry adjusting some of your joints to ensure that after computation of any joints there are no zero-thickness locations.\nKerf Compensation The lasers on campus cut along the centerline. To get nominal-size parts, we\u0026rsquo;ll offset the geometry a little so that everything lines up.\nAdd a Kerf Compensation feature, select the \u0026ldquo;By Thickness\u0026rdquo; mode, and enter one of the plate thicknesses you input earlier. I find that for 0.25\u0026thinsp;in/6\u0026thinsp;mm materials, using a kerf of 0.01\u0026thinsp;in and an allowance of 0.001\u0026thinsp;in works well; keep the same allowance and assume a 0.008\u0026thinsp;in kerf for 0.125\u0026thinsp;in/3\u0026thinsp;mm parts. To be extra precise, cut a test square in your material on your laser and measure the kerf.\nNest the Parts for Cutting You now have an assembly with all joints computed, and you need to get them to a laser.\nOur first approach will be the Auto Layout feature, which uses a rectangular bin-packing algorithm to lay out all parts of a given thickness. This can lead to inefficient packings, but is an excellent place to start, as it\u0026rsquo;s the easiest option.\nAuto Layout Add an Auto Layout feature. You have the option of defining the size of the sheet you will be cutting it from and the spacing to leave between parts. The checkboxes allow you to make multiple copies of every part, and also to show the sheet outlines for convenience. Multiple copies can be useful when making several copies of an identical subcomponent. Note that the feature automatically lays out only flat parts of the thickness you have selected, and moves the remaining features out of the way.\nRepeat this procedure for each different thickness of part you want to cut.\nCreate Drawings and Export DXFs To create a drawing from an Auto Layout part studio, we\u0026rsquo;ll make an Onshape drawing containing the required geometry.\nCreate a new drawing, selecting a custom format, large page size, and no annotations.\nNow insert the top view of the entire part studio in which we added the joints and did the layout. You\u0026rsquo;ll need to check the leftmost input selection in order to directly add the entire part studio. Make sure the scale is set to 1:1.\nNow select the \u0026ldquo;crop\u0026rdquo; tool, and draw a spline around just one of the sheets that AutoLayout generated.\nNow add a sheet to the drawing and repeat this insert view/crop procedure for each cut sheet that Auto Layout generated.\nThere\u0026rsquo;s other ways to assemble everything into discrete drawings and extract a DXF, including just right-clicking on a part and choosing \u0026ldquo;export as DXF.\u0026rdquo;\nDoing it this way, however, means that as long as the number of cut sheets generated by Auto Layout doesn\u0026rsquo;t change, you can propagate design changes all the way through to the cropped drawing views without having to redo the setup portions of this process. Especially when you end up making many small changes, this can make it significantly easier to recut entire assemblies.\n Before exporting as DXF, measure your actual stock and if necessary update the thickness variables defined at the top of the document. If you\u0026rsquo;ve been using those variables everywhere, this should be a really easy way to compensate for odd material thicknesses and get the joints sized so they almost snap-fit (e.g. I find the 1/4\u0026quot; Duron from PRL is usually not quite 1/4\u0026quot; or 6mm).\nTo export a single part, simply right-click a face and choose \u0026ldquo;Export as DXF/DWG\u0026hellip;\u0026rdquo; and download. Since the laser joint is order dependent, symmetric parts will not necessarily have symmetric joints, so export each part individually.\nIf you\u0026rsquo;re cutting the entire assembly, you can right-click the drawing tab in Onshape and export as either DXF or as a PDF, depending on which works better for your printer.\nNow just throw it on a USB stick and head over to the laser cutter, you\u0026rsquo;re all set to start making some parts.\n  Other Layout Methods   So you\u0026rsquo;re here because you\u0026rsquo;ve got a bunch of individual DXFs for each part. Now we need to lay these out efficiently so that we can make the most of the material when we cut. This operation is called \u0026ldquo;nesting.\u0026rdquo;\nTry to use the Auto Layout method detailed above if you can; it\u0026rsquo;s much easier. For more complex shapes though, you\u0026rsquo;ll need to use an actual nesting solution.\nSVGnest is a free, open-source solution, but only accepts SVG files. To use this, you\u0026rsquo;d need to use something to convert your DXF to SVG and then nest. You can find it at svgnest.com.\nDeepnest is downloadable, and takes DXF input. As of this writing, if is both free as in beer and free as in open source. This is a more configurable version of the SVGnest algorithm, and tends to give better results on complicated geometries. You will have to let it run for a while to get a near-optimal result, as it\u0026rsquo;s based on a genetic algorithm solution. You can find it at deepnest.io\n   Contributed by Arul Suresh, 4 May 2020.\n  Be honest, you did, didn\u0026rsquo;t you? \u0026#x21a9;\u0026#xfe0e;\n Or, if you\u0026rsquo;re, say, making an icosahedron, more than three. \u0026#x21a9;\u0026#xfe0e;\n   "},{"uri":"http://spdldaemon.github.io/docs/applicationnotes/magneticfieldsensing/","title":"Magnetic Field Sensing","tags":[],"description":"","content":"If this looks overly mathematical, don’t worry, you can certainly skip the math and get something working by trial and error as is commonly done. If you take this approach, you still might want to check out the section on matching your coil resonance to the track frequency to minimize noise picked up from other sources. Either way, it’s usually helpful to understand the underlying physics when it comes to troubleshooting or improving your sensors. Also, some quick, back of the envelope calculations can often get you in the ballpark a lot quicker than random experimentation.\nBasic E\u0026amp;M A current flowing in an infinite wire will generate a magnetic field that circles around the wire (in a direction given by the right hand rule – align your thumb with the current, and your fingers point in the \\(B\\) field direction) whose strength drops off with \\(1/r\\):\n$$B=\\frac{\\mu_0 i}{2\\pi r}$$\nwhere \\(\\mu_0 = 1.26 \\times 10^{-6} \\mathrm{H}/\\mathrm{m}\\) is the vacuum permeability, \\(i\\) is the current in Amps, and \\(r\\) is the distance from the wire in meters.\nSo if there is a sinusoidal current flowing in the wire that looks like\n$$ \\begin{aligned} i \u0026amp;= 0.1 \\sin \\omega t \\\\ \\omega \u0026amp;= 2\\pi f \\\\ f \u0026amp;= 20000 \\end{aligned} $$\nIt will generate a magnetic field around the wire that varies sinusoidally in time:\n$$ B = \\frac{\\mu_0}{2\\pi r} \\cdot 0.1 \\sin \\omega t $$\nDetection An easy way to detect a magnetic field is to take advantage of the fact that when the magnetic flux in a loop of wire changes, a voltage is generated in the coil that is proportional to the rate of change:\n$$ \\begin{aligned} V \u0026amp;= -\\frac{\\partial\\Phi}{\\partial t} \\\\ \\Phi \u0026amp;= B \\cdot A\\end{aligned} $$\nwhere \\(B\\) is the magnetic field, and \\(A\\) is the coil area. We assume that \\(B\\) is constant over the area of the coil, which is a good approximation when the coils are small.\nCalculating the peak induced voltage for a 1\u0026thinsp;cm diameter coil located 10\u0026thinsp;cm from the wire, we get:\n$$ \\begin{aligned} V \u0026amp;= -\\frac{\\partial}{\\partial t} \\left( \\frac{\\mu_0}{2\\pi r} \\cdot 0.1 \\sin \\omega t \\right) \\cdot A \\\\ \u0026amp;= \\omega \\cdot \\left( \\frac{\\mu_0}{2\\pi r} \\cdot 0.1 \\cos \\omega t \\right) \\cdot A \\\\ V_\\mathrm{peak} \u0026amp;= 2.52 \\thinspace \\mathrm{\\mu V} \\end{aligned} $$\nwhich is a miniscule value, and would not be able to see it on a typical oscilloscope with 5\u0026thinsp;mV resolution. To increase your signal, you can connect several of these sensor loops in series. If you have \\(N\\) turns on your coil, you will get an induced voltage that is \\(N\\) times larger than the result for a single loop. With 1000 coils on the same sensor as above, you would see 2.52\u0026thinsp;mV, which is something you can work with. This still needs amplification, but a relatively simple op-amp circuit will do.\nSo at some fixed distance from the wire, there are two things you can do to increase your signal—increase coil area or number of turns:\n$$ V \\propto N \\cdot A $$\nCoils as Inductors Any time you have a coil, you also have an inductor. For a coil with length much greater than diameter, the inductance is:\n$$ L = \\frac{\\mu_0 A N^2}{l} $$\nwhere \\(A\\) is the coil area, \\(N\\) the number of turns, and \\(l\\) the length of the coil.\nFor a practical coil that may have a length similar in magnitude to the diameter, this is only an approximation good to within a factor of 2 or so. To increase the inductance, inductors are often wound around core materials. These cores effectively amplify the magnetic field (and therefore inductance), by anywhere from factors of 10s to 1000s. Iron is commonly used at low frequencies, and ferrite is used at higher frequencies.1\nAlso, real inductors always have some capacitance, resulting from the numerous turns of wire wound next to one another. There is always capacitance between two neighboring wires, increasing with decreasing separation.2 This capacitance can easily be on the order of 10s to 100s of pF for a peanut-sized coil.\nYou might think, \u0026lsquo;who cares about picoFarads anyways\u0026rsquo;—that is, until you see a mysterious high frequency ringing on a coil that you thought was an ideal inductor. You may be able to see this with sensors that are not designed to resonate at the track frequency (as described below) but resonate at some other frequency (i.e. the “self-resonant” frequency that depends on coil capacitance \u0026amp; inductance). A simple model of what this can look like can be generated in circuitmaker:\nThe sinusoidal source is simulating the signal from the track, the lower magnitude square wave source is simulating quick noise pulses that might be generated from motor switching, etc. The resulting waveforms show hi-frequency ringing at the self-resonant frequency (triggered by the noise spikes) riding on top of the desired 20\u0026thinsp;kHz signal waveform:\nLC Resonance and Signal Amplification You can make a functional sensor using a coil as described above, although it may need to be pretty big (large area, lots of turns) in order to give you a signal large enough to work with. By adding a capacitor in parallel with your coil (and effectively in parallel with the internal coil capacitance), you can make a circuit that resonates at the track frequency. The frequency of this resonance is given by:\n$$ f = \\frac{1}{2\\pi\\sqrt{LC}} $$\nThe effect of this is that a small signal from the track can drive a much larger oscillation in the parallel inductor capacitor circuit, which is easier to detect. The effective amplification of a circuit like this can easily be on the order of 10-100. You can model the induced voltage in the coil as a sinusoidal voltage source in series with the inductor:3\nIf you could build this circuit and then swept the frequency knob on the function generator, you’d get a plot of \\(V_\\mathrm{in}/V_\\mathrm{out}\\) vs. frequency that looks like:\nIf you actually used ideal components4 and turned the knob very slowly, you’d find that the peak at 20\u0026thinsp;kHz was infinite.\nThis measure of the sharpness of resonance is called the quality factor, or Q, of the circuit. For this circuit, it is infinite. Q is defined as the resonant frequency divided by the width in frequency units of the curve at the point where it is \\(1/\\sqrt{2}=0.707\\) times the maximum value.5\nSuppose all the ideal inductors are used up and you have to order a real inductor from Digi-Key. You find that it has 26\u0026thinsp;\u0026Omega; of resistance due to the many turns of thin wire. You plug this into your circuitmaker model:\nand get this response:\nNow instead of having an infinite peak, the resonant circuit amplifies the field signal by about 40. Since the peak is no longer infinite, you happily calculate Q to be 40. Another handy Q formula for a series resistor like this is:\n$$ Q = \\frac{2\\pi\\omega_\\mathrm{res} L}{R} $$\nNow, suppose Mark Merlo was playing with the function generator and tweaked the frequency knob so it’s generating 21\u0026thinsp;kHz instead of 20\u0026thinsp;kHz. Now the gain of the resonant circuit goes from 40 down to 9, just after you spent hours calibrating your code to work with a gain of 40. So that’s problem #1: your circuit is sensitive to small changes in track frequency. Eventually, Sara figures out what the deal is and recalibrates the knob to 20.0001\u0026thinsp;kHz. Luis is just starting to build his circuit but Brandon stole all of his capacitors to extend the range of the electric banana. Fortunately, he manages to find a pair with the exact value he needs in the cabinet of freedom, and they even have a ±5\u0026thinsp;% tolerance (good as far as capacitors go). Suppose one of the caps is dead on the labeled value, and the other is 5\u0026thinsp;% high, so that circuit will have a resonant frequency of 19.5\u0026thinsp;kHz. Now the gain will be approximately 17 for that sensor and 40 for the other sensor—not a very well matched pair of sensors.\nThese undesirable effects of a sharp resonance peak can mitigated by lowering the Q even more, which flattens out the peak. An easy way to do this is with a parallel resistor:\nIf you only have a parallel capacitor (in the location of the 10\u0026thinsp;k\u0026Omega; resistor) and replace the 26\u0026thinsp;\u0026Omega; capacitor with a wire, the Q is given by:6\n$$ Q = 2\\pi f_\\mathrm{res} RC $$\nwhere \\(C\\) is the total capacitance summing the coil and external capacitances.\nIf you have both resistors in the circuit, the resultant Q is well approximated by $$ \\frac{1}{Q_\\mathrm{total}} = \\frac{1}{Q_\\mathrm{R,series}} + \\frac{1}{Q_\\mathrm{R,parallel}} $$\nThis expression may even be exact, who knows? Anyways, the peak is quite a bit flatter now so that if the frequency shifts by 1\u0026thinsp;kHz to 21\u0026thinsp;kHz, the signal only changes by 20\u0026thinsp;%, which is a lot better than the factor of 4 we saw above.\nThis parallel resistor that lowers the Q of the circuit is sometimes called a Q-killer resistor for obvious reasons. You’ll want to pick a Q-killer resistor that gives you good amplification without too sharp of a resonant peak which would result in sensitivity to slight frequency variations.\nNoise Rejection If there is EM noise at frequencies other than the track frequency,7 it will also generate a signal in your sensors. Suppose you have a coil without a resonant capacitor, and the rate of change of magnetic flux from the switched motor current is the same as the rate of change of magnetic flux due to the wire under the track, in the location of your sensor. Then an equal voltage will be produced in the sensor, which will show up as noise that is just as large as your signal. If your sensor is part of a tuned circuit that amplifies the track frequency by a factor of 10, then the induced noise from the motor will be 1/10 of the track signal, which is a good thing.\nThere are a few things you can do to minimize magnetic noise generated by the motor.\n  Don’t put your sensors right next to your motors.\n  Run the current supply and return wires for a motor close together. If you run them in a big open loop (and maybe wrap them around your sensors a few times), they will generate much larger magnetic fields \u0026amp; hence more sensor noise.\n  Don’t switch motor currents faster than you need to. For the LMD18200’s, this means leaving off the bootstrap capacitors (which (when added) cause the MOSFETs in the H-bridge to turn on and off a lot faster). When you turn off a MOSFET real fast, the current through it and all the associated wiring changes real fast (large di/dt). This causes any associated magnetic fields to change real fast (which is what your sensors detect), and also causes voltage drops across the wires that were supplying the current due to the inductance of these supply wires.\n  Decreasing switching speed is entirely different from decreasing PWM frequency—lowering the PWM frequency will not affect the switching speed. The MOSFETs still switch on/off at the same speed, they just switch less often at a lower PWM frequency.\n Signal Amplification After all this work (actually, its not that bad, just a few components soldered in parallel), you’ll still probably want to amplify your signal. One feature of the resonant circuits described above is that they do not have very high output impedance—that is, if you try drawing significant currents from them it will load them down and kill the resonance. Kind of like sticking a tuning fork in a block of cheese—the fork will not continue to shake the cheese at 1 kHz for minutes. Instead, the vibrations will quickly die down to nothing.\nTwo ways to deal with this low-impedance sensor are to buffer the signal or simply use a non-inverting op-amp configuration (as shown below):\nAs long as the op amp doesn’t saturate (output goes to one rail or the other), this will work pretty well. The LM6144s have the \u0026lsquo;\u0026lsquo;interesting\u0026rsquo;\u0026rsquo; property that if an output saturates and the inputs are no longer held at the same voltage (no longer ideal \r), then the input impedance drops drastically, which can load the sensor down and kill the resonance. This can make for some frustrating debugging sessions until you figure out what’s happening.\nOnce you’ve amplified the signal, you can either build a peak detector circuit or do the peak detection in software. Given the amount of other stuff going on in software, the peak detector circuit is not a bad choice. Choose your R \u0026amp; C carefully to give the best compromise between smooth signal and fast response to signal changes:\nTime constant, \\(\\tau=RC\\), too small (excessive ripple):\nTime constant, \\(\\tau=RC\\), too large (output doesn\u0026rsquo;t track input):\nSensor Locations \u0026amp; Sensor Signal Math Once you’ve got your sensors working, where do you put them and what do you do with them? First of all, there are three basic sensor orientations. We’ll call these the Horizontal, Vertical, and Parallel (referring to the axis of the coil). When your sensor axis is parallel with the wire, the field is all perpendicular to the coil, so there is no field component going through the coil, and you get no signal. So, you can forget about those. Vertical and Horizontal coils are more useful.\nFor a coil that is located a horizontal distance \\(x\\) from the wire and a height \\(h\\) above the wire, the magnitude of the component of the field that is actually passing through the coil (aligned with the coil axis) is given by:\n$$ \\begin{aligned} B_\\mathrm{h} \u0026amp;= \\frac{\\mu_0 i h}{2\\pi\\left(x^2+h^2\\right)} \\quad \\mathrm{horizontal\\space{}coil} \\\\ B_\\mathrm{v} \u0026amp;= \\frac{\\mu_0 i x}{2\\pi\\left(x^2+h^2\\right)} \\quad \\mathrm{vertical\\space{}coil} \\end{aligned} $$\nFor a horizontal sensor at fixed height \\(h_0\\), if you plot the normalized signal in the sensor over a range of \\(x\\) values that span \\(\\pm3h_0\\) you will get something looking like:\nSuppose you have two sensors, each mounted a distance \\(h_0\\) from the center of the robot. Assume horizontal distance \\(x\\) increases positively to the right of the wire. For a sensor mounted at \\(x = +h_0\\), the sensor will be over the wire when the center of the robot is at \\(x = -h_0\\), so plotting the right sensor signal as a function of the position of the robot center gives us something like:\nThe left sensor signal is found in exactly the same way, and its peak will occur when the center of the robot is at \\(x = +h_0\\). If you read these signals into the HC12 and subtract them in software (Left Sensor – Right Sensor), you get a signal which is roughly proportional to the deviation of the robot center from the wire, over a limited range centered about a deviation of 0.\nIf you use the summed signal for feedback control, be aware that if the wire is not between the sensors, the sense of the signal can invert. For example, going from \\(x=-1\\) to \\(x=0\\), the value of the summed signal is increasing. However, this is also true when going from \\(x=-2\\) to \\(x=-3\\)—away from the wire. Keep this in mind when deciding how your robot will respond.\n You can follow the exact same procedure to make plots of vertically mounted sensors, or different horizontal sensor configurations (heights, spacing). Similarly, by manipulating your sensor signals with simple math, you may find some resultant signal that works better for whatever you want to do with the position information.\nOther Sensing Tidbits   If your sensors are mounted near any conductive materials (aluminum and copper in particular), induced currents will flow in the metals that partially cancel out the fields that you are trying to measure. So mounting your sensors on aluminum rails probably would not be a good idea.\n  You’ll have to have a fairly accurate capacitance to set the resonant frequency where you want it. There are 5\u0026thinsp;% and 10\u0026thinsp;% tolerance polyester caps for sale with the coil/inductors. Two advantages of these caps over ceramic caps is tolerance (20\u0026thinsp;% is typical on ceramic) and low capacitance change with change in temperature (not sure what the specs are but these type of capacitors typically change an order of magnitude less than ceramic caps for a given change in temperature).\n  If you’re trying to dial in your total capacitance by adding small parallel capacitors, the tolerances on these smaller caps are much less important than the tolerances on the larger caps that make up the bulk of the capacitance. For example, if a parallel cap provides the final 10\u0026thinsp;% of capacitance with a 10\u0026thinsp;% capacitance tolerance, it will only contribute about 1\u0026thinsp;% to the overall tolerance range.\n   Contributed by Oliver Max, 20 Feb 2002.\nAdapted for web by Arul Suresh, 11 January 2020.\n  Ferrite has much lower losses at high frequencies since it is an electrical insulator and doesn’t let internal dissipative eddy currents flow as iron does. \u0026#x21a9;\u0026#xfe0e;\n For two wires with radius \\(r\\) and separation \\(s\\), the capacitance is \\(C=\\pi\\epsilon/\\log\\left(s/r\\right)\\)where \\(\\epsilon\\) is the permittivity of the insulator, typically 2-6 times \\(\\epsilon_0\\), the permittivity of free space. \u0026#x21a9;\u0026#xfe0e;\n In this model, you have access to the outer leads of the sinusoidal source and inductor in your real-world inductor, but not the one connecting the two. \u0026#x21a9;\u0026#xfe0e;\n Available in the TA office for a slight premium. \u0026#x21a9;\u0026#xfe0e;\n That is, \\(\\infty/0\\) for this curve, which as we all know is \u0026ldquo;a suffusion of yellow\u0026rdquo; in your calculator. \u0026#x21a9;\u0026#xfe0e;\n Currently just copied, and this sentence clearly got jumbled at some point. \u0026#x21a9;\u0026#xfe0e;\n For example, from the switching of motor currents. \u0026#x21a9;\u0026#xfe0e;\n   "},{"uri":"http://spdldaemon.github.io/docs/tools/","title":"Tools","tags":[],"description":"","content":"Tools Tutorials, Tips, and Tricks for the various software and hardware tools you might encounter in lab.\n"},{"uri":"http://spdldaemon.github.io/docs/tools/kicad/","title":"KiCad","tags":[],"description":"","content":"KiCad1 is an open-source software tool for the creation of electronic schematic diagrams and PCB artwork. Although essentially treated as one program, KiCad is really more of a tight grouping of the following stand-alone software tools:\n   Program name Description File extension     KiCad Project manager *.pro   Eeschema Schematic and component editor *.sch, *.lib, *.net   Pcbnew Circuit board and footprint editor *.kicad_pcb, *.kicad_mod   GerbView Gerber and drill file viewer *.g*, *.drl, etc.   Bitmap2Component Convert bitmap images to components or footprints *.lib, *.kicad_mod, *.kicad_wks   PCB Calculator Calculator for components, track width, electrical spacing, color codes, and more\u0026hellip; None   Pl Editor Page layout editor *.kicad_wks    The file extension list is not complete and only contains a subset of the files that KiCad supports. It is useful for the basic understanding of which files are used for each KiCad application. KiCad is mature open-source software, and is robust enough for typical use in lab as well as for more involved, complex electronic board designs.\n  KiCad basic window. The icon row from left to right corresponds to Eeschema (schematic and component editors), Pcbnew ( board and footprint editors), GerbView, Bitmap2Component, PCB Calculator, and Pl Editor.\n  This tutorial is written using KiCad 5.0.0 on Windows 10. While significant changes are unlikely, be aware that small details may change if your install is different.\n KiCad does not present any board-size limitation and it can easily handle up to 32 copper layers, up to 14 technical layers and up to 4 auxiliary layers. KiCad can create all the files necessary for building printed boards, Gerber files for photo-plotters, drilling files, component location files and a lot more. KiCad also incorporates ngspice, an open-source circuit simulator.\nBeing open source (GPL licensed), KiCad represents the ideal tool for projects oriented towards the creation of electronic hardware with an open-source flavor.\nOn the Internet, the homepage of KiCad is: http://www.kicad-pcb.org/\nDownloading and installing KiCad KiCad runs on GNU/Linux, Apple macOS and Windows. You can find the most up to date instructions and download links at:\nhttp://www.kicad-pcb.org/download/\nUnder Apple macOS Stable builds of KiCad for macOS can be found at: http://downloads.kicad-pcb.org/osx/stable/\nUnder Windows Stable builds of KiCad for Windows can be found at: http://downloads.kicad-pcb.org/windows/stable/\nUnder GNU/Linux   Show Unix Installation Details   Stable releases of KiCad can be found in most distribution’s package managers as kicad and kicad-doc. If your distribution does not provide latest stable version, please follow the instruction for unstable builds and select and install the latest stable version.\nUnder Ubuntu, the easiest way to install an unstable nightly build of KiCad is via PPA and Aptitude. Type the following into your Terminal:\nsudo add-apt-repository ppa:js-reynaud/ppa-kicad sudo aptitude update \u0026amp;\u0026amp; sudo aptitude safe-upgrade sudo aptitude install kicad kicad-doc-en Under Debian, the easiest way to install backports build of KiCad is:\n# Set up Debian Backports echo -e \u0026#34; # stretch-backports deb http://ftp.us.debian.org/debian/ stretch-backports main contrib non-free deb-src http://ftp.us.debian.org/debian/ stretch-backports main contrib non-free \u0026#34; | sudo tee -a /etc/apt/sources.list \u0026gt; /dev/null # Run an Update \u0026amp; Install KiCad sudo apt-get update sudo apt-get install -t stretch-backports kicad Under Fedora the easiest way to install an unstable nightly build is via copr. To install KiCad via copr type the following in to copr:\nsudo dnf copr enable @kicad/kicad sudo dnf install kicad Alternatively, you can download and install a pre-compiled version of KiCad, or directly download the source code, compile and install KiCad.\n  KiCad Workflow Despite its similarities with other PCB design software, KiCad is characterized by a unique workflow in which schematic components and footprints are separate. Only after creating a schematic are footprints assigned to the components.\nOverview The KiCad workflow is comprised of two main tasks: drawing the schematic and laying out the board. Both a schematic component library and a PCB footprint library are necessary for these two tasks. KiCad includes many components and footprints, and also has the tools to create new ones.\nInitially, the process begins with schematic capture, as in any other tool. After the schematic has been defined, footprints are attached to each symbol on the schematic, and the information is then used to lay out the board.\nThe KiCad Tutorial has a detailed flowchart of the full board design process.\n Some Notes on Fabrication Both Oshpark (PCB only) and MacroFab(PCB + assembly) directly accept KiCad formats for fabrication. Naturally neither is the cheapest possible service, but for small projects the convenience can be an advantage.\n Adapted in part from the KiCad Getting Started Tutorial, CC-BY-3.0  .\n  Pronounced \u0026lsquo;Key-CAD\u0026rsquo;. \u0026#x21a9;\u0026#xfe0e;\n   "},{"uri":"http://spdldaemon.github.io/docs/applicationnotes/","title":"Application Notes","tags":[],"description":"","content":"Application Notes SPDL-curated approaches to solving common problems.\n"},{"uri":"http://spdldaemon.github.io/docs/applicationnotes/audiomodems/","title":"Audio Modems and the PIC","tags":[],"description":"","content":"Normally, audio signal processing is done on a dedicated digital signals processing (DSP) chip—there\u0026rsquo;s a reason that a multiply and accumulate (MAC) instruction is the first one added, since there\u0026rsquo;s a lot of that to go around when processing a more complicated tone of any sort. We\u0026rsquo;ll start by looking at what it takes to simply generate and receive clean audio tones when using the PIC, and discuss some more involved signal processing that can improve robustness and enable multiple tone detection at the cost of significant processing time1. The rest of this document assumes a PIC16F15356, although differences on different processors will be called out where relevant.\nAnalog Modulation Analog modulation works by taking a carrier and modulating its parameters using the data to be encoded, so that the carrier can transmit the data to whoever you\u0026rsquo;re talking to.\nIf we look at a pure sine wave as a possible carrier, then what parameters do we have available to modulate? We might describe the carrier wave as follows:\n$$ C = A \\sin{\\omega t + \\phi} $$\nWhere \\(A\\) is the amplitude, \\(\\omega\\) the frequency2, and \\(\\phi\\) the phase3.\nAmplitude is the most natural modulation; for example, we can encode a 1 as a loud tone, and a 0 as a soft tone. However, this method is not very robust to variations in the communication channel: how do you tell if the transmitting device is just farther from the microphone today, or transmitting all zeros on purpose? Is that just someone clapping in the background, or a set of ones?\nWhat if we encode the data as variations rather than absolute levels? This will work—this is how AM radio works—but the data rate is much lower than the carrier wave frequency.\nFrequency is probably the next most natural modulation; by choosing different frequencies, we can communicate different information4. Frequency relies on time implicitly, and since time isn\u0026rsquo;t affected by a non-ideal transmission channel, this method is more robust than the amplitude modulation above5. This type of modulation is known as frequency shift keying (FSK). Typically, one frequency will be defined as the \u0026ldquo;mark\u0026rdquo; frequency, and will encode a 1. Another frequency will be defined as the \u0026ldquo;space\u0026rdquo; frequency, encoding 0. When used with only two frequencies, this method is called binary frequency shift keying (BFSK). However, there\u0026rsquo;s nothing magic about choosing only two frequencies: by choosing four frequencies, for example, each symbol can encode a dibit, potentially doubling the data rate. The limitation is the ability of the receiver to distinguish closely spaced frequencies, and the bandwidth available in the carrier.\nDual-Tone Multiple Frequency (DTMF) encoding can also be used. You\u0026rsquo;ve most likely seen this if you\u0026rsquo;ve dialed an actual landline telephone6. There are several possible frequencies, and for any given symbol, two tones are superimposed, and the combined tone represents the information. In the case of a phone, 4 \u0026ldquo;low\u0026rdquo; frequencies correspond to each row of the keypad, and 4 \u0026ldquo;high\u0026rdquo; frequencies correspond to each column of the keypad7. For DTMF as implemented on a phone, this means 8 tones encode 16 symbols. If the restriction of exactly one tone from each set is relaxed, then \\(n\\) tones can encode \\(n(n-1)/2\\) symbols. If you define your own system and allow either 1 or 2 tones, this gives you \\(n(n+1)/2\\) symbols from \\(n\\) tones.\nPhase modulation is the last possible modulation, as the description of the sine wave only has three parameters. Phase is only defined with respect to another reference—the phase of a single sine wave in isolation isn\u0026rsquo;t well defined. Like with amplitude, phase modulation can be done relative to the previous value of the carrier. Phase modulation is used in many commercially implemented systems, as it offers advantages in data rate for a given bandwidth. However, the modulation and demodulation are more complex, and so we won\u0026rsquo;t consider this mode further here.\nTone Generation We\u0026rsquo;ll start with the transmission side of the communication channel: how do we get nice tones out of our PIC?\nSingle Tones Let\u0026rsquo;s start with the simpler case: Let\u0026rsquo;s say we want to generate tones of only one frequency at a time, alternating between two or more tones to convey information.\nThe easiest way to generate a frequency on a PIC is to use the CCP peripheral, set it up to control an output pin, and generate a square wave.\nA square wave isn\u0026rsquo;t very nice as an audio source though—a square wave contains all the harmonics of the frequency of the signal you\u0026rsquo;re generating, and so if any of the components you\u0026rsquo;re using to transduce the voltage signal to or from actual audio have any resonances, they\u0026rsquo;ll almost certainly be excited.\nThe obvious solution is to filter it. Let\u0026rsquo;s generate a 1\u0026thinsp;kHz square wave between 0\u0026thinsp;V and 1\u0026thinsp;V, and add an RC filter with a corner at 1.6\u0026thinsp;kHz:\nIf we look at VOUT, we get the following:\nwhich still has sharp edges and enough of the harmonics to possibly cause issues. Let\u0026rsquo;s add three more filter stages:\nIf we look at VOUT, we get the following:\nwhich has only 0.3\u0026thinsp;% error from a pure sine wave at 1\u0026thinsp;kHz. However, instead of a peak to peak amplitude of 1\u0026thinsp;V, we\u0026rsquo;re left with a peak to peak amplitude of only 0.19\u0026thinsp;V. Worse, let\u0026rsquo;s say we want to transmit a range of tones, and so we feed the same filter with 300\u0026thinsp;Hz:\nNot only are we back to more of a sharktooth shape due to the harmonics at 900\u0026thinsp;Hz and 1500\u0026thinsp;Hz, the peak-peak amplitude is now 0.7\u0026thinsp;V, which is nearly 4 times higher. Using a passive filter like this, while simpler to implement in software, reduces signal amplitude and reduces the available frequencies to a small range8. For the specific hardware we\u0026rsquo;re using, the resulting low peak-peak amplitude is small enough that the speaker volume will not be high enough to robustly transmit information.\nGeneration of constant-amplitude sine waves can be achieved by using the digital-to-analog converter (DAC) peripheral on the 16F15356. The DAC has 5-bit resolution, and outputs a constant analog voltage. By using a lookup table and changing the DAC output at periodic intervals, a sine wave can be approximated.\nWhy do we want to use a lookup table and not just compute the value on the fly? It all comes down to processing time.\nWhile a purpose-built chip intended for DSP might have the appropriate hardware instructions and clock speed to actually compute a sine function in real time, doing so would require a lot of floating-point math. Even on chips with floating-point implemented in hardware, this will be much slower than using integer math everywhere. On a processor like the PIC16F15356, with no hardware multiply, 8-bit word size, and a relatively low clock, doing even integer multiplication and division can be too much computation to fit into a high-rate interrupt.\nUsing a lookup table means that we can do all of the math ahead of time. Usually, this means doing the computations when we\u0026rsquo;re writing our code, on a proper computer, and inserting a const array in the program. Sometimes, this can mean computing the lookup table in code, but doing it slowly outside an interrupt while there are no time-critical functions running—if the lookup table depends on measurements made while your code is running, for example.\nA lookup table doesn\u0026rsquo;t necessarily have to be a direct representation of a repeating waveform either. If you needed to actually compute sines on a microcontroller, you\u0026rsquo;d typically include a lookup table sineTable such that sineTable[d] held the value of \\(\\sin \\frac{d}{2\\pi}\\), for example.\n The DAC output has a high source impedance, and so it should be unity buffered; as the output is a stepped sine wave, it must also be filtered to remove harmonics. However, here a single RC filter stage suffices to smooth the waveform sufficiently.\nThe lookup table can be implemented using either a fixed time reference and a desired output at each timestep, or using fixed voltage offsets and varying timesteps between output values.\nOne approach is to sample the waveform at a constant timestep, \\(T_\\mathrm{s} = 1/F_\\mathrm{s}\\), as seen in the following images. By sampling the sine wave at fifteen points over a full cycle, we obtain the desired output at each point, in red. However, these points have precise magnitude; if we assume that we can only generate multiples of 0.25, then we need to discretize these points to the possible output values, in yellow. Finally, we output these by setting the output to the discretized value at a constant rate, resulting in the black stepped waveform.\nIn code, this might look something like\nstatic const float table[14] = {0.0, 0.5, 0.75, 1.0, 1.0, 0.75, 0.5, 0, -0.5, -0.75, -1.0, -1.0, -0.75, -0.5}; static char index = 0; Note that we stop at the point just before completing the cycle; when we step through this table, the next point will be index 0, ensuring a smooth repeat of the waveform.\nI\u0026rsquo;m using floats here to match the waveform exactly; remember that rule 1 of embedded microcontrollers is \u0026ldquo;Only use integer math, and preferably only add.\u0026rdquo; You\u0026rsquo;ll want to match the output values to whatever your hardware expects.\n Our generation code, called at regular intervals, might look something like\noutput = table[index]; index = (index + 1) % 14; so that the index steps through each element in turn.\nArbitrary modulus operations (e.g. ++i % c where c is not a power of 2) are expensive on a low-power microcontroller. Depending on the intelligence of the compiler, even where c is a power of 2, using the modulo operator % may result in an expensive computation.\nEither use tables of length \\(2^n\\) and use a mask to perform the modulo (e.g. ++i \u0026amp;= 0x03 to count modulo 4), or if a table of a specific length is required, check explicitly for the index reaching the table end and reassign the index: if ( ++i \u0026gt;= len) i = 0;\n Note that this previous version happens to skip 0.25 entirely. We can also discretize by ensuring we output each possible value, and vary the time step, as here:\nIn this particular case, the relative timesteps are symmetric, and so we can set this up as follows:\nstatic const float table[16] = {0, 0.25, 0.5, 0.75, 1.0, 0.75, 0.5, 0.25, 0, -0.25, -0.5, -0.75, -1.0, -0.75, -0.5, -0.25}; static const unsigned int delta[16] = {d0, d1, d2, d3, d3, d2, d1, d0, d0, d1, d2, d3, d3, d2, d1, d0}; static char index = 0; Our update might then look something like\noutput = table[index]; delayToNext = delta[index]; index = ++index \u0026amp; 0xF; Note that the delta at a given index corresponds to how long the value at that same index is output.\nBoth approaches allow for relatively easy modification of the output frequency when generating a single tone, by dynamically adjusting the delay between successive output values. Using a fixed time delta simplifies this on a low-power microcontroller, as the delay scaling only needs to be calculated once per output frequency, and not once per sample.\nPractical Considerations:\nThere\u0026rsquo;s a few things to note here on how to actually implement a lookup table method like this. The first is that looking at the example tones above, they\u0026rsquo;re square, blocky, and not very similar to the underlying sine wave; here it\u0026rsquo;s intentional for illustrative purposes, but that\u0026rsquo;s not what you want if you\u0026rsquo;re trying to generate an actual sine-like output.\nUsing the fixed-value variable-time approach will scale to be as good as your DAC resolution allows, and you\u0026rsquo;ll only have to worry about running updates too quickly. Using a fixed-time update is more flexible in terms of tuning, where the natural way to improve signal quality is to increase the update rate.\nWhat\u0026rsquo;s the upper bound on how fast we can go? One constraint comes from the hardware: each DAC will have some nominal settling time, and attempting to update faster than that rate may cause a reduction in performance. Another constraint comes from processing: even though simply copying a table value to an output takes little time, if you do it too often you\u0026rsquo;ll be spending all your time in the interrupt and none of it running any of your actual code. Any time you\u0026rsquo;re setting up a control or signal processing interrupt like this, make sure you time it to see what fraction of CPU time it\u0026rsquo;s consuming.\nWhat\u0026rsquo;s the lower bound on how fast we want to go? This one is less of a bound and more of a guideline. Fundamentally, you want to make sure you\u0026rsquo;re running your output loop fast enough that the resulting wave looks like you want it to. A rough rule of thumb here is to choose an update rate at least 10 times faster than the highest frequency you want to use, as long as that\u0026rsquo;s feasible with respect to your upper bound. If you can run the update faster, consider going fast enough that your lookup table contains each output value at least once—for example, table[N] = { 0, 1, 2, 3, 3, 2, 1, 0, ...} rather than table[N] = { 0, 2, 3, 2, 0, -2, -3, ...}. This is a better indicator that you\u0026rsquo;re representing the desired waveform smoothly; depending on the specific output requirements, acceptable performance may need an even faster update, but these rough guidelines can give you a good place to start.\nAnother note: depending on your particular microcontroller, if you have multiple lookup tables, it can be significantly faster to define each table as a 1-D array, rather than combining them as a single 2-D array—array lookups using a variable as the index can be slow.\nMultiple Tones Generation of multiple tones at once can be accomplished by computing two tones, adding them in software, and then using the result to set the DAC output. Here, it is desirable that all tones use a single interrupt, and so this suggests using a constant time delta to discretize all of the output frequencies. To avoid discontinuities, each lookup table will correspond to a full cycle of a sine wave at a given frequency, resulting in lookup tables of differing lengths as the frequency changes. An index into each lookup table will then need to be tracked separately, with each being incremented at a common rate.\nThis might look something like\nstatic const float table0[8] = {0.0, 0.3, 0.5, 0.3, 0.0, -0.3, -0.5, -0.3}; static const float table1[4] = {0.0, 0.5, 0.0, -0.5}; static char index0 = 0; static char index1 = 0; Note that each individual lookup table is scaled so that the sum still fits within our available output range. Another option would be to add more precise values initially, but scale before actually generating the output. The output code might look something like\noutput = table0[index0] + table1[index1]; index0 = ++index0 \u0026amp; 0x7; index1 = ++index1 \u0026amp; 0x3; Single Tone Decoding Where decoding a single tone, if the input signal is clean enough, the normal 218A/B approach to detecting an oscillating signal serves perfectly well. Design a series of filters to remove noise, re-center the waveform, and use a comparator to digitize the signal. The resulting signal can then be used as an input to the CCP peripheral, and the timing between edges used to determine the frequency.\nMultiple Tone Decoding If you\u0026rsquo;re attempting to detect the presence of multiple tones at once, you\u0026rsquo;ll have to dive in and actually do some signal processing. For starters, connect the input signal to the analog-to-digital converter (ADC) on the chip, so that we can do some math on it. Second, let\u0026rsquo;s talk about that math, because there\u0026rsquo;s a lot of it, and you need the right algorithm to have any hope of this working.\nThe Goertzel Algorithm Most engineers are at least familiar with the concept of a Fast Fourier Transform (FFT), which takes in a time-varying signal, and outputs a set of amplitudes for each possible frequency9. However, calculating the full FFT (even though it\u0026rsquo;s \u0026ldquo;fast\u0026rdquo;), is still very math-intensive. If you\u0026rsquo;re only interested in detecting a small number of frequencies out of the many possible frequencies, the Goertzel Algorithm is much more efficient in terms of total operations.\nAs with an FFT, the algorithm works with blocks of samples, so let\u0026rsquo;s define some parameters:\n\\(F_\\mathrm{s}\\), the sampling frequency, in Hertz.\n\\(N\\), the block size.\n\\(f_i\\), the ith frequency of interest.\nSample rate must be selected to satisfy at minimum the usual Nyquist constraints: \\(F_\\mathrm{s}\\) must be at least twice the frequency of the highest frequency you want to detect. You may, however, get better results by increasing the sampling rate further. For the sake of demonstration, let\u0026rsquo;s assume we\u0026rsquo;ll sample at 4\u0026thinsp;kHz.\nBlock Size is essentially a balance between specificity in detected frequency and length of the sample10. \\(N\\) directly controls frequency precision, as for a 4\u0026thinsp;kHz sample rate, choosing \\(N=100\\) will mean each response bin is 40\u0026thinsp;Hz, and frequencies less than this distance apart will be essentially impossible to distinguish.\nOf course, increasing \\(N\\) to increase the frequency discrimination increases the sampling time (and in our case, much more so the processing time). Choosing \\(N=400\\), for instance, means that it will take 100\u0026thinsp;ms just to collect the data.\nYou also want the target frequencies to be centered in their respective bins, which means you want \\(f_i = k_i F_\\mathrm{s}/N\\) where the \\(k_i\\) are all integers.\nUnlike the FFT, \\(N\\) can be any number, and not just powers of 2.\nThe algorithm can be formulated as a recursive computation, and so breaks down into computation of constants, a per-sample update, and an end-of-block magnitude calculation.\nPrecomputed Constants:\nBegin by defining\n$$k_i = \\left\\lfloor \\frac{1}{2} + N\\frac{f_i}{F_\\mathrm{s}} \\right\\rfloor$$\n\\(k_i\\) is then used to compute the required coefficients for that frequency:\n$$ \\begin{aligned} \\omega_i \u0026amp;= \\frac{2\\pi}{N} k_i \\\\ C_i \u0026amp;= 2\\cos\\omega \\end{aligned} $$\nSample Update: The recursive formulation of the algorithm requires the value of the previous two evaluations, and so define for each frequency three values, \\(Q_0\\), \\(Q_1\\), and \\(Q_2\\). At the beginning of each block, \\(Q_1\\) and \\(Q_2\\) must be initialized to 0.\nAt each sample \\(x\\), update the values as follows:\n$$ \\begin{aligned} Q_0 \u0026amp;= C \\cdot Q_1 - Q_2 + x \\\\ Q_2 \u0026amp;= Q_1 \\\\ Q1 \u0026amp;= Q_0 \\end{aligned} $$\nBlock magnitudes: At the end of each block, the magnitude of the target frequency can be computed as\n$$ M = Q_1^2 + Q_2^2 - Q_1 \\cdot Q_2 \\cdot C $$\nComparing \\(M\\) for each target frequency then tells you which of those frequencies, if any, are present in the signal. Note that as written this ignores phase information in favor of getting a magnitude result with the minimum number of calculations.\nGeneric Implementation Now we can talk about implementing the algorithm on a generic microcontroller. While for some applications it may make sense to compute the constants at runtime, particularly for smaller, RAM-constrained processors, we\u0026rsquo;ll want to do those at compile time, so that we can place them in the flash. For most microcontrollers, we won\u0026rsquo;t necessarily have access to a hardware floating-point multiply, and so we\u0026rsquo;ll also want to refactor everything to use integer math.\nFixed-point math is one way of dealing with small values while not incurring the expense of floating-point operations.\nEven where floating-point hardware exists, integer math is likely to be faster, at the cost of some precision.\nA fixed-point representation of a number simply adds a virtual decimal point at a specific location in the number; for familiarity, let\u0026rsquo;s look at some examples in base 10.\nLet\u0026rsquo;s say I want to multiply 3.4 and 1.7. The result (with an explicit decimal point) is 5.78. Now let\u0026rsquo;s scale up the first two numbers by 10, so that they don\u0026rsquo;t have a decimal point, giving us 34 and 17, with a product of 578. There\u0026rsquo;s nothing magic about the decimal point, we just need to keep track of where it would be. Since we scaled both inputs by 10, the output is scaled by 100. Dividing the output by the scaling factor gives us 57, which is the result when using fixed-point decimal computation with one digit corresponding to fractions. Note that we\u0026rsquo;ve lost some precision, since we\u0026rsquo;re only reserving one digit to correspond to the fractional part of the result.\nWe can do the same thing in binary, treating a fixed number of bits \\(b\\) as the post-decimal-point bits, corresponding to values of 1/2, 1/4, 1/8, etc. The scale factor would then be \\(S=2^b\\). Again, every multiplication will need to be scaled down by \\(S\\) to keep the numbers scaled correctly. For two numbers \\(a\\) and \\(b\\), each with a scaling of \\(S=2^b\\), we have that the product \\(p = ab/S\\). In code, this looks like p = (a * b) \u0026gt;\u0026gt; b.\n Let\u0026rsquo;s define a scaling factor of the form \\(S=2^b\\) where \\(b\\) is an integer. Let\u0026rsquo;s assume that we have precomputed the constants offline and put the \\(C_i\\) in a lookup table. For them to be fixed-point integer types, we\u0026rsquo;ll have to scale each constant by \\(S\\) and truncate as we do the computation.\nNow we can define holding space for the \\(Q\\), and have the following set of variables:\n#define F NUM_OF_FREQUENCIES #define N BLOCK_SIZE #define b SCALING_BITS  static const int32_t C[F] = { ... }; static int32_t Q0; static int32_t Q1[F]; static int32_t Q2[F]; static int32_t M[F]; Note that the \\(C\\) and \\(Q\\) can all be negative, hence the signed types, but the magnitude will end up being positive.\nWe can now go through and perform the updates as we get each sample \\(x\\):\nfor (uint8_t i = 0; i \u0026lt; F; i++){ Q0 = x + ((C[i]*Q1[i])\u0026gt;\u0026gt;b) - Q2[i]; Q2[i] = Q1[i]; Q1[i] = Q0[i]; } where we shift right by \\(b\\) bits to maintain scaling.\nIn C99, technically using \u0026gt;\u0026gt; to shift a signed value is undefined and compiler dependent. Most compilers will perform an arithmetic shift (i.e. extending the sign bits, resulting in division), but it\u0026rsquo;s always good to double check. The MPLAB XC8 C compiler does in fact perform an arithmetic right shift on negative numbers.\n And finally, at the end of the block, we update the magnitudes:\nfor (uint8_t i = 0; i \u0026lt; F; i++){ M[i] = ((Q1[i]*Q1[i])\u0026gt;\u0026gt;b) + ((Q2[i]*Q2[i])\u0026gt;\u0026gt;b) - (( ((Q1[i]*Q2[i])\u0026gt;\u0026gt;b) * C[i])\u0026gt;\u0026gt;b); } Where the final term is bit shifted twice to maintain scaling.\nAt this point, if you have a 32-bit microcontroller and it has a hardware multiply instruction (e.g. the Tiva), you\u0026rsquo;re set! fixed-point integer math should mean that this algorithm is fast enough to run real-time, running one sample update each time you make a measurement. Unfortunately, the same cannot be said for an 8-bit PIC with no hardware multiply.\n Making it work on a PIC16F15356 You\u0026rsquo;ll notice that there are a lot of 32-bit multiplications in the previous generic implementation. The PIC16F15356, on the other hand, doesn\u0026rsquo;t even have an 8-bit multiply instruction, and if you try to implement the full 32-bit version above, you\u0026rsquo;ll be waiting a very long time to get any results.\nHowever, we can make a lot of optimizations that allow us to improve the processing time to where this could be feasible for low-baud rate communication with a complex symbol set to keep a reasonable data rate11.\nLet\u0026rsquo;s start with the fixed-point scaling, \\(b\\). We definitely want this to be 8 in this case—the PIC is an 8-bit processor, and handling things in 8-bit chunks is a natural fit. The precomputed cosine term ends up being about 1 for most target frequencies, and so using an 8 bit scaling factor means we can represent it at taking 8 bits.\nMultiplication and digits in the resulting representation will end up being critical for these optimizations. Let\u0026rsquo;s say we have a number in base \\(B\\), having \\(k\\) digits. The largest \\(k\\)-digit number is then given by \\(B^k-1\\); e.g. the largest 2-bit number is \\(2^2-1 = 3 = 0\\mathrm{b}11\\). If we multiply the largest \\(n\\)-digit number with the largest \\(m\\)-digit number, we get $$ (B^n-1)(B^m-1) = B^{n+m} - B^n - B^m + 1$$\n\\(B^{n+m}\\) is the smallest number with \\(n+m+1\\) digits; with the two subtractions, we therefore know that the product has at most \\(n+m\\) digits. This is an excessively involved way of saying that 99 times 99 is less than 10,000. The useful part is that if we take an 8-bit number and multiply it with an 8-bit number, we know we can represent the result with at most 16 bits.\n The first part of our new setup is to store all the measurements in a buffer, as we know we won\u0026rsquo;t be able to do the math fast enough to do it live in the interrupt. We can define a buffer static volatile uint8_t data[N] to store the values in each block of measurements, along with a flag static volatile bool dataReady to indicate to the main program when the block has been measured. Whether or not the ADC has 8-bits of resolution, we\u0026rsquo;ll only take the measurement as an 8-bit number to keep everything byte-aligned.\nFor these inputs (C is 8/9 bits, data is 8 bits), the Q end up being 16 bits each, and are signed types, so we have, for example, the set of Q for the zeroth frequency to detect defined as static int16_t Q0[3], such that Q0[0] is \\(Q_0\\) for frequency 0, Q0[1] is \\(Q_1\\) for frequency 0, and so on.\nSome 32-bit multiplications are unavoidable, but the bit shift afterward also turns out to be somewhat expensive on our PIC. To get around this, we\u0026rsquo;ll use a custom type and a union to directly access the bytes we want.\nIn C, a union is essentially just telling the compiler you want to treat an area of memory as multiple formats, depending on how you perform the access—in English, it\u0026rsquo;s something like \u0026ldquo;I want this area of memory to behave like a 16-bit number when I access it using the name number, and as a 2-element byte array when I access it using the name bytes\u0026rdquo;\n Each step of processing involves multiplying \\(Q_1 \\cdot C\\), which is a 16-bit and an 8-bit12 number, resulting in a 24-bit number. Rather than shifting the result by 8 bits, we\u0026rsquo;ll define a custom type as follows:\nstruct ltype { int8_t trunc; int16_t intval; // access middle two bytes directly to avoid division  int8_t space; }; typedef union RESULT_T { int32_t l; struct ltype hold; // Allows direct access to bytes of 16-bit data } RESULT_T; static RESULT_T Qhold; // Holding space for intermediate calculations The ltype struct defines a 4-byte region of memory, as an 8-bit, 16-bit, and 8-bit chunk in series. As the PIC is little-endian, the least-significant bytes come first, so trunc is the LSBs we throw away, intval is the final 16-bit result we\u0026rsquo;re after after shifting by our 8-bit scale factor, and space is ideally extra space that never holds data. The RESULT_T type is a union, so we can treat the 4-byte region as a single 32-bit type using l, or as a struct using hold. So we do the multiplication, and put the result into Qhold.l, treating the memory location as a long. We then pull out the scaled result by accessing Qhold.hold.intval, and proceed with the update:\n// per-sample filter update // assume new sample (uint8_t) is in data[i] int16_t x; x = data[i] - 127; // center around zero to reduce  // size of computed Q  // assume we\u0026#39;re processing frequency n Qhold.l = (int32_t) Cn * (int32_t) Qn[1]; Qn[0] = x; Qn[0] += Qhold.hold.intval; Qn[0] -= Qn[2]; Qn[2] = Qn[1]; Qn[1] = Qn[0]; At this point, after having computed all of the per-stage updates, we have \\(Q_1\\) and \\(Q_2\\) which are each 16-bit values.\nThe magnitude computation involves squaring each \\(Q\\), as well as multiplying \\(Q_1\\), \\(Q_2\\), and \\(C\\). Without any adjustment, this last multiplication would give us a 4-bit number. However, at this point we\u0026rsquo;re only interested in relative magnitude, and each term has two copies of a \\(Q\\) term—if we scale the \\(Q\\) to 8 bits at this point, then the result is a 24-bit number, and we can use the same struct to extract the final 16-bit value.\nHowever, the \\(Q\\) are, at this point, of variable size, and so we\u0026rsquo;ll run through them to see how many bits each actually requires to represent. We\u0026rsquo;ll define uint16_t bitTest = 0 and uint8_t shift = 0.\nFor each frequency n, check how many bits \\(Q_1\\) and \\(Q_2\\) take:\nif (Qn[1].i \u0026gt;= 0) bitTest |= Qn[1].i; else bitTest |= (~Qn[1].i) \u0026lt;\u0026lt; 1; if (Qn[2].i \u0026gt;= 0) bitTest |= Qn[2].i; else bitTest |= (~Qn[2].i) \u0026lt;\u0026lt; 1; For positive numbers, the leading bits will be 0, so we can simply or the number to find the highest bit that was set. For negative numbers, the leading bits are 1, and so we need to find the last bit that is set before the first leading zero (due to the two\u0026rsquo;s complement representation and needing to keep a sign bit). We do this by inverting the bits and left-shifting by one, then combining with bitTest.\nAfter doing this for all frequencies, we know the maximum size of all of the \\(Q\\), and so we can compute a bit shift based on the largest:\n// Compute shift from highest bit that is set if (bitTest \u0026amp; (1 \u0026lt;\u0026lt; 15)) shift = 8; else if (bitTest \u0026amp; (1 \u0026lt;\u0026lt; 14)) shift = 7; else if (bitTest \u0026amp; (1 \u0026lt;\u0026lt; 13)) shift = 6; else if (bitTest \u0026amp; (1 \u0026lt;\u0026lt; 12)) shift = 5; else if (bitTest \u0026amp; (1 \u0026lt;\u0026lt; 11)) shift = 4; else if (bitTest \u0026amp; (1 \u0026lt;\u0026lt; 10)) shift = 3; else if (bitTest \u0026amp; (1 \u0026lt;\u0026lt; 9)) shift = 2; else if (bitTest \u0026amp; (1 \u0026lt;\u0026lt; 8)) shift = 1; and then for each frequency, shift to make it exactly 8 bits:\n// Filter n Update Qn[1].i \u0026gt;\u0026gt;= shift; Qn[2].i \u0026gt;\u0026gt;= shift; Now we can do the multiplication, putting the result in Qhold, then extracting and adding to the \\(Q^2\\) terms which are each 16-bit:\n// Filter n magnitude calculation Qhold.l = (int32_t) Qn[1] * (int32_t) Qn[2] * (int32_t) Cn; M[n] = ((Qn[1] * Qn[1]) +(Qn[2] * Qn[2]) -(Qhold.hold.intval)); // Reset Filter n Qn[1] = 0; Qn[2] = 0; And now you can inspect M to figure out which, if any, frequencies are present. Note that for speed, everything is explicitly defined—nowhere do we reference an array with a non-constant index, except when getting measurements in and out of the data buffer. This means that yes, your code will involve lots of copies of the same code with different literal indices inserted. As you\u0026rsquo;d be generating these tables over and over again to adjust and debug, I\u0026rsquo;d suggest using Python or MATLAB and code templates to statically generate your copy-pasted code on demand. That way, you can debug the structure of the code once, and then automatically generate lookup tables, Qn constants, and so on as you change frequencies, number of distinct frequencies, and so on.\nTradeoffs Of course, the PIC16F15356 is by no means a DSP chip. Implementing a DTMF approach will necessarily reduce your baud rate, as (roughly speaking), detecting 8 frequencies with a sample rate of 4\u0026thinsp;kHz and a block size of 47 takes about 12\u0026thinsp;ms to measure, but about a further 60\u0026thinsp;ms to process. This means each symbol must be spaced far enough apart for listening devices to be able to complete measurement of the previous symbol, resulting in a baud rate of about 10. However, it\u0026rsquo;s feasible to have a large symbol set of maybe 20 symbols, meaning the bit rate can still be about 40-50. Reducing the baud rate further and increasing the block size can allow for more finely-spaced signals, which should be able to further increase the bit rate.\nUsing the DSP approach does also offer more robustness to relatively-low amplitude harmonics that cannot be easily filtered due to the characteristics of the physical transmission channel (e.g. cheap speakers or microphones, etc.)\nOn the other hand, generating single tones allows for ease of detection, as the signal can be digitized, and zero-crossings precisely timed to extract a frequency. For a signal using BFSK near 500\u0026thinsp;Hz13, if we assume that robust detection of a bit takes 10 zero-crossings, then your baud rate (and bit rate) is 50. Increasing the number of symbols can again improve your bit rate; using 4 tones and encoding dibits improves your bit rate to 100.\nIn terms of tone generation, both approaches are about comparable, as the lookup table and interrupt setup are nearly identical in both cases.\n References  G. Held, \u0026ldquo;Asynchronous Modems and Interfaces,\u0026rdquo; in Understanding Data Communications, 2nd ed., Howard W Sams \u0026amp; Company, 1987. \u0026ldquo;The Goertzel Algorithm,\u0026rdquo; Embedded, 28 Aug 2002. Online. A. Vitali, \u0026ldquo;The Goertzel algorithm to compute individual terms of the discrete Fourier transform (DFT),\u0026rdquo; DT0089, ST Microelectronics , 2017. Silicon Labs, \u0026ldquo;DTMF Decoder Reference Design,\u0026rdquo; AN218, 2005.   Contributed by Arul Suresh, 1 May 2020.\n  At least, on a PIC that doesn\u0026rsquo;t have a hardware multiply, is 8-bits, and running on only a 32\u0026thinsp;MHz clock. \u0026#x21a9;\u0026#xfe0e;\n In radians per second; the frequency in cycles per second (i.e. Hertz) is given by \\(f = \\frac{\\omega}{2 \\pi}\\). \u0026#x21a9;\u0026#xfe0e;\n Again, in radians. \u0026#x21a9;\u0026#xfe0e;\n For a reference implementation of this method, see the \u0026ldquo;Police Station (Silly Voices)\u0026rdquo; sketch from Monty Python\u0026rsquo;s Flying Circus, Series 1, Ep. 12: The Naked Ant. \u0026#x21a9;\u0026#xfe0e;\n Of course, this will still have issues if one of you is moving toward and away from the microphone or speaker at an appreciable fraction of the speed of sound. Or if you\u0026rsquo;re traveling at relativistic speeds and time behaves differently. Or if you\u0026rsquo;re trying to communicate between a Nitrogen and Helium atmosphere. But for most cases, it works great! \u0026#x21a9;\u0026#xfe0e;\n Let\u0026rsquo;s be real, this is rapidly approaching the point of \u0026ldquo;no one but Ed has had this experience,\u0026rdquo; if we\u0026rsquo;re not already there yet. \u0026#x21a9;\u0026#xfe0e;\n Yes, I said 4 columns! The characters are A, B, C, and D, although keypads actually using those buttons were phased out way before DTMF on actual phones was. The corresponding tones are often used as control signals. \u0026#x21a9;\u0026#xfe0e;\n If we assume an ideal filter such that all frequencies below the filter bandwidth \\(f_\\mathrm{BW}\\) are passed with unity gain, and all frequencies above are perfectly blocked, the range of usable frequencies is \\(\\frac{1}{3}f_\\mathrm{BW} \u0026lt; f \u0026lt; f_\\mathrm{BW}\\). Since the filter rolloff is not ideal, the available frequency range will be smaller; if roughly equal amplitude is required, it will be smaller still. \u0026#x21a9;\u0026#xfe0e;\n Frequencies from \\(0\\) to \\(F_\\mathrm{s}/2\\), since any frequency above that cannot be detected because of the Nyquist Theorem. \u0026#x21a9;\u0026#xfe0e;\n For a related discussion on frequency, duration, and precision, check out 3blue1brown\u0026rsquo;s excellent video on the underlying math. \u0026#x21a9;\u0026#xfe0e;\n Plus, it\u0026rsquo;s cool! Definitely pushing the hardware is an interesting way to figure out what is and isn\u0026rsquo;t possible. \u0026#x21a9;\u0026#xfe0e;\n Well, 8-ish bits. But even though it\u0026rsquo;s often actually 9-bits to represent (because \\(C = 2S\\cos\\omega \\approx 2*256 = 512\\)), it\u0026rsquo;s one of the smaller possible 9-bit numbers, and so in practice treating it as 8 for the purposes of calculating scaling works out fine. \u0026#x21a9;\u0026#xfe0e;\n You probably want to stick to tones under 1\u0026thinsp;kHz for your own sanity. High pitched tones are really annoying—take a look at the Fletcher-Munson curves. \u0026#x21a9;\u0026#xfe0e;\n   "},{"uri":"http://spdldaemon.github.io/docs/applicationnotes/joystickinput/","title":"Notes on Joystick Implementation","tags":[],"description":"","content":"Understanding Joystick Output The output from the joystick is fully analog, using potentiometers to covert the joystick motion into a voltage you can measure. The figure below shows the internal circuity of the joystick.\nYou can then apply the resistor divider equation to get the voltages VRx and VRy:\n$$ V_i = V_\\mathrm{CC} \\frac{V_\\mathrm{sweep}}{V_\\mathrm{total}}$$\nNotice that this equation is fully linear with respect to the rotation of the joystick.\nA digital system cannot directly read an analog voltage, so \\(V_i\\) is measured with an analog-to-digital converter (ADC). Since this returns a binary number1 that represents the voltage input to the ADC, we use the idea of \u0026ldquo;counts\u0026rdquo; to represent the measured value.\nADCs are typically characterized by how many \u0026ldquo;bits\u0026rdquo; they have. You might hear of, for example, an 8-bit ADC, or a 10-bit ADC, or a 16-bit ADC. This number refers to the size of the binary number the ADC passes to the processor: an 8-bit ADC would output, say, 0b00101100 or 0b11101011—and is capable of all values from \\(0\\) to \\(2^N-1\\). An 8-bit ADC can therefore output 256 unique values, while a 16-bit ADC can output 65536.\nThese numbers are evenly distributed between two reference points against which the ADC is measuring the signal. Typically, these are ground and the supply rail, but may vary in general.\n For a 10-bit ADC, like we have on the PIC, we have that 0\u0026thinsp;V is 0x00, and \\(V_\\mathrm{CC}\\) is 0x3FF2.\nThis numeric value then has to be converted to a \u0026ldquo;control\u0026rdquo; by your code. Thinking in counts can make your life easier here.\nControl Mappings Let\u0026rsquo;s now walk through the process of taking the raw ADC measurement and getting a useful control signal out of it.\nGetting a Control Value We start be defining a few terms. We let the \u0026ldquo;player\u0026rdquo; be the thing controlled by the joystick, and we define the player state as the vector \\(\\mathbf{s}\\) and the control as \\(\\mathbf{u}\\). We will also define the raw output of the joystick as \\(\\mathbf{j}\\). That is,\n$$ \\mathbf{s} = \\begin{bmatrix} x \\\\ y \\end{bmatrix}, \\mathbf{j} = \\begin{bmatrix} C_x \\\\ C_y \\end{bmatrix}, $$\nwhere \\(C_i\\) are the measured values from the ADC in counts, and \\(x\\) and \\(y\\) are the coordinates of the player.\nIn order to get \\(\\mathbf{u}\\) we can perform a linear transformation on \\(\\mathbf{j}\\) by multiplication with a scaling matrix \\(\\mathbf{M}\\) and adding an offset vector \\(\\mathbf{b}\\):\n$$ \\mathbf{u} = \\mathbf{M}\\mathbf{j} + \\mathbf{b} $$\n$$ \\mathbf{M} = \\begin{bmatrix} m_x \u0026amp; 0 \\\\ 0 \u0026amp; m_y \\end{bmatrix}, \\mathbf{b} = \\begin{bmatrix} b_x \\\\ b_y \\end{bmatrix} $$\nThis will transform our joystick output to a control through a linear mapping3. Other mappings are possible4, but linear is the simplest to implement. All the above equations can be reduced if only 1 axis of the joystick is used. Note that \\(\\mathbf{M}\\) is a diagonal matrix—this ensures that we\u0026rsquo;re only scaling each joystick axis independently, and not coupling the axes to each other or rotating them.\nSpend time on this! Converting your joystick output to a control can make or break your gameplay. Tune your controls carefully to get the desired feel when playing. Play around with \\(\\mathbf{M}\\) and \\(\\mathbf{b}\\) to see what works well and what doesn’t—typically, you\u0026rsquo;ll find it most useful to re-center the input around 0 as part of the processing, as it makes the remaining math much simpler. If you feel compelled to use a different transformation technique, go for it! Also consider stability; you don’t want your player bouncing all over the place either.\nNow that we have a control mapping technique, what control options do we have? There are two main types, position and velocity mapping.\nPosition Mapping Position mapping is quite intuitive5. Wherever the joystick goes, the player goes. In mathematical terms:\n$$ \\mathbf{s}_t = \\mathbf{u}_t + \\mathbf{s}_0 $$\nwhere \\(\\mathbf{s}_t\\) and \\(\\mathbf{u}_t\\) represent the state and control vectors at time \\(t\\), and \\(\\mathbf{s}_0\\) the initial state. Essentially, this means that the player will be positioned on the screen wherever the joystick is. If the joystick is moved to the extreme left, the player goes to the extreme left. When the joystick snaps back to center, the player snaps back to center as well. This type of control is not seen often.\nVelocity Mapping The more popular control scheme is where the joystick controls the velocity of the player rather than position. Essentially, the user creates a velocity vector by moving the joystick, and this velocity is then applied to the player, causing the player to move around. In mathematical terms:\n$$ \\mathbf{s}_t = \\mathbf{s}_0 + \\int_0^t \\mathbf{u}_τ \\,\\mathrm{d}τ $$\nOf course, performing an integral is not possible in a discrete environment, thus we have to use a summation technique. Furthermore, we want to use an iterative approach since we cannot get an absolute control as a function of time, thus we convert the integral expression to the following:\n$$ \\mathbf{s}_t = \\mathbf{s}_{t-1} + \\mathbf{u}_t \\Delta t $$\nThis is an Euler integration approach that is the simplest to implement. There are other techniques, such as trapezoidal integration or Simpson\u0026rsquo;s Rule, that you can also experiment with. Here we only need to know the previous state. Then, using the control and time between the current and last measurement, we can calculate what the state should be at the current time.\nThe keen reader will note that we have not specified any stability criterion, as Euler really only works for the correct \\(\\Delta t\\). While this is true when trying to converge to a solution, in our usage, we do not worry about convergence since we are not trying to reach a specific solution. Since the user will be playing the game, they will correct for their motions inherently. The only caveat is to ensure \\(\\Delta t\\) is small enough to make the motion appear smooth to the user.\nUsability If you\u0026rsquo;ve tried experimenting with the \\(\\mathbf{M}\\) and \\(\\mathbf{b}\\) matrices, and you still can\u0026rsquo;t find a control mapping you\u0026rsquo;re happy with, you may want to look at some more advanced mappings to help usability. When you\u0026rsquo;re trying to control things with a velocity-mapped controller, it\u0026rsquo;s typically the case that\n When you\u0026rsquo;re near zero, you want to remain still, even if your hand is jittering a little, or is busy moving the other joystick axis. When you\u0026rsquo;re near zero, you want more precise control over small velocities.  These can be addressed by applying deadbands and cubic mappings. Pretty much every analog input you use in your life—computer mice, some volume knobs, joysticks on your gaming console—will typically do one or more of these to make the inputs feel smoother and more intuitive. Sometimes these will do even more complicated mappings, like adding acceleration based on the time you hold a particular velocity, or by modifying the mapping function based on the speed of the input. These are outside the scope of this note, but simply to point out that when mapping controls, the sky\u0026rsquo;s the limit6.\nDeadband The simplest way to damp out micromotions near zero (when the user wants to be still) is to simply ignore any value with small absolute value:\n$$ d(x) = \\begin{cases} 0 \u0026amp; |x| \\lt \\delta \\\\ x \u0026amp; |x| \\geq \\delta \\end{cases} $$\nwhere \\(\\delta\\) is half the total width of the deadband. This ends up looking like this:\nNotice that while small inputs near zero don\u0026rsquo;t accidentally move the player, the user also can\u0026rsquo;t make very small movements. The output suddenly jumps from 0 to a value when leaving the deadband, so the user can never command values smaller than this.\nScaled Deadband To fix this, we can scale the function outside the deadband so it smoothly goes to the same value at the ends from zero:\n$$ g(x) = \\begin{cases} 0 \u0026amp; |x| \\lt \\delta \\\\ \\frac{f(x) - \\text{sign}\\,x \\cdot f(\\delta)}{\\max_x f(x) - f(\\delta)} \u0026amp; |x| \\geq \\delta \\end{cases} $$\nwhere again \\(\\delta\\) is half of the total deadband width, \\(x\\) is the input, and \\(f(x)\\) is a continuous odd function. Setting \\(f(x)=x\\) gives us a scaled linear deadband, like so:\nNow when the deadband ends, the user can still apply arbitrarily small inputs if they choose to, so that\u0026rsquo;s an improvement.\nCubic Scaling However, this still sacrifices smoothness and precision near zero; using a cubic scaling can help with balancing range and precision. We define \\(c(x)\\) as follows:\n$$ c(x) = \\omega x^3 + (1-\\omega)x $$ where \\(\\omega \\in [0,1]\\) can be thought of as a blending factor, mixing linear and cubic responses; for \\(\\omega=0\\), we have \\(c(x)=x\\) and get a straight mapping of input to output. As \\(\\omega\\) is increased, the function approaches \\(x^3\\), reducing sensitivity near zero:\nScaled Cubic Deadband But now we\u0026rsquo;ve lost the deadband. However, it so happens that this particular function is, in fact, a continuous odd function, so we can just plug it back into \\(g(x)\\) in place of \\(f(x)\\), giving us a scaled cubic deadband:\nThis gives you a lot more flexibility in how exactly you choose to map your inputs to your outputs. This may not even be something you want in all cases, so don\u0026rsquo;t feel like this is the only answer. The only right answer is the one that makes your game fun and enjoyable to play.\n Contributed by Riyaz Merchant and Arul Suresh, 6 Nov 2020.\n  Since it\u0026rsquo;s a pure number, it has no units, which is also partly why it makes more sense to think of it as \u0026ldquo;counts\u0026rdquo;. \u0026#x21a9;\u0026#xfe0e;\n That\u0026rsquo;s 1023 in decimal. Remember that \\(2^{10}\\) is 1024, but since 0 is a possible value, the 1024th number we can represent is 1023. \u0026#x21a9;\u0026#xfe0e;\n Yes, yes, technically adding \\(\\mathbf{b}\\) makes it affine, we know. \u0026#x21a9;\u0026#xfe0e;\n And, in fact, are somewhat common in this type of input processing. More on this when we talk about usability. \u0026#x21a9;\u0026#xfe0e;\n At least, intuitive to write the code\u0026hellip; \u0026#x21a9;\u0026#xfe0e;\n Pun somewhat intended. Modern aircraft have many flight modes, where the control stick input is mapped in a way that incorporates the aircraft dynamics, so that moving the stick isn\u0026rsquo;t interpreted as a command to move a control surface a certain amount, but as a command to have the entire aircraft move in a particular way. \u0026#x21a9;\u0026#xfe0e;\n   "},{"uri":"http://spdldaemon.github.io/docs/","title":"The SPDL Docs Repository","tags":[],"description":"","content":"The SPDL Docs Repository Welcome to the SPDL Docs Repository!\nThis is a work in progress, and is intended to eventually serve as a repository for SPDL-curated best practices, tools, and tips.\nIf you feel extra motivated to write a whitepaper on a topic, you can clone the Github repository, add the page, and make a pull request for SPDL Daemon to review. In this case, you may find the linked documentation at the lower left to be helpful when adding your page. This site is built using Hugo, with the Learn theme.\n"},{"uri":"http://spdldaemon.github.io/docs/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"http://spdldaemon.github.io/docs/tags/","title":"Tags","tags":[],"description":"","content":""}]