[
{
	"uri": "http://spdldaemon.github.io/docs/tools/kicad/usingkicad/",
	"title": "Using KiCad",
	"tags": [],
	"description": "",
	"content": "KiCad is pretty powerful, and as with many open-source software, can sometimes have a steep learning curve. For the purposes of use in lab, the rest of this tutorial will focus on things you might use reasonably often. The detailed information can always be found in the KiCad documentation.\nThat being said, your life will be enormously easier if you get used to some of the keyboard shortcuts for navigation.\nShortcut keys KiCad has two kinds of related but different shortcut keys: accelerator keys and hotkeys. Both are used to speed up working in KiCad by using the keyboard instead of the mouse to change commands.\nAccelerator keys Accelerator keys have the same effect as clicking on a menu or toolbar icon: the command will be entered but nothing will happen until the left mouse button is clicked. Use an accelerator key when you want to enter a command mode but do not want any immediate action.\nAccelerator keys are shown on the right side of all menu panes:\nHotkeys A hotkey is equal to an accelerator key plus a left mouse click. Using a hotkey starts the command immediately at the current cursor location. Use a hotkey to quickly change commands without interrupting your workflow.\nTo view hotkeys within any KiCad tool go to Help\r\rList Hotkeys or press Ctrl+F1:\nYou can edit the assignment of hotkeys, and import or export them, from the Preferences\r\rHotkeys Options menu.\nIn this document, keypresses are expressed with styling like this: a. If you see a, just type the \u0026ldquo;a\u0026rdquo; key on the keyboard.\n Example Consider the simple example of adding a wire in a schematic.\nTo use an accelerator key, press Shift+w to invoke the \u0026ldquo;Add wire\u0026rdquo; command (note the cursor will change). Next, left click on the desired wire start location to begin drawing the wire.\nWith a hotkey, simply press w and the wire will immediately start from the current cursor location.\nGetting Around By default, the mouse wheel zooms in and out. Holding Shift while scrolling will scroll the page up and down, while holding Ctrl will scroll left and right. Panning can also be done by holding down the middle mouse button (wheel) and dragging.\nStarting a New Project Each project in KiCad needs a dedicated directory, and has a *.pro file defining the project. To create a project, go to the KiCad man window, then select File\r\rNew\r\rProject\u0026hellip; or simply press Ctrl+N. When making the project, leave the checkbox to create a new directory ticked unless you already have a dedicated directory.\n"
},
{
	"uri": "http://spdldaemon.github.io/docs/tools/kicad/schematiccapture/",
	"title": "Schematic Capture",
	"tags": [],
	"description": "",
	"content": "Eeschema EEschema is KiCad's schematic capture and annotation tool; this is where you'll be drawing your schematics by placing components and hooking them up. If you haven't already, start or open a project to hold the schematic.\nBefore stepping through this tutorial, download the teensy.lib symbol library from https://github.com/XenGi/teensy_library.\nSome useful shortcuts The keyboard shortcuts you'll be using most frequently for schematics are:\n a - add a component. c - copy a component. w - wire components together. e - edit a component. v - edit component value. Esc - escape any command in progress. Ctrl+z - undo. Ctrl+s - save.  Creating a Schematic   Let’s begin by creating a schematic. Start the schematic editor Eeschema, . It is the first button from the left.\n  Click on the \u0026lsquo;Page Settings\u0026rsquo; icon on the top toolbar. Set the appropriate paper size (\u0026lsquo;A4\u0026rsquo;, \u0026lsquo;8.5x11\u0026rsquo;, etc.) and enter the Title as \u0026lsquo;Tutorial\u0026rsquo;. You will see that more information can be entered here if necessary. Click OK. This information will populate the schematic sheet at the bottom right corner. Use the mouse wheel to zoom in. Save the whole schematic: File\r\rSave\n  We will now place our first component. Click on the \u0026lsquo;Place symbol\u0026rsquo; icon in the right toolbar. You may also press the \u0026lsquo;Add Symbol\u0026rsquo; hotkey a.\n  Click on the middle of your schematic sheet. A Choose Symbol window will appear on the screen. Note that several thousand schematic symbols may be loaded, so make frequent use of search.\nWe’re going to place a resistor. Search / filter on the \u0026lsquo;R\u0026rsquo; of Resistor. You may notice the \u0026lsquo;Device\u0026rsquo; heading above the Resistor. This \u0026lsquo;Device\u0026rsquo; heading is the name of the library where the component is located, which is quite a generic and useful library.\n  Once you use a symbol, it will be listed at the top with other recently used symbols, making filling in passives easier.\n  Double click on it. This will close the Choose Symbol window. Place the component in the schematic sheet by clicking where you want it to be.\n  Try to hover the mouse over the component \u0026lsquo;R\u0026rsquo; and press r. The component should rotate. You do not need to actually click on the component to rotate it.\n  Sometimes, if your mouse is also over something else, a menu will appear. You will see the Clarify Selection menu often in KiCad; it allows working on objects that are on top of each other. In this case, tell KiCad you want to perform the action on the \u0026lsquo;Symbol …​R…​\u0026rsquo; if the menu appears.\n Right click in the middle of the component and select Properties\r\rEdit Value. You can achieve the same result by hovering over the component and pressing v. Alternatively, e will take you to the more general Properties window. Notice how the right-click menu below shows the hotkeys for all available actions.  The Edit Value Field window will appear. Replace the current value \u0026lsquo;R\u0026rsquo; with \u0026lsquo;1k\u0026rsquo;. Click OK  Do not change the Reference field (R?), this will be done automatically later on. The value above the resistor should now be \u0026lsquo;1k\u0026rsquo;.\n  To place another resistor, simply click where you want the resistor to appear. The symbol selection window will appear again.\n  The resistor you previously chose is now in your history list, appearing as \u0026lsquo;R\u0026rsquo;. Click OK and place the component.\n  In case you make a mistake and want to delete a component, right click on the component and click \u0026lsquo;Delete\u0026rsquo;. This will remove the component from the schematic. Alternatively, you can hover over the component you want to delete and press Del.\n  You can also duplicate a component already on your schematic sheet by hovering over it and pressing c. Click where you want to place the new duplicated component.\n  Right click on the second resistor. Select \u0026lsquo;Drag\u0026rsquo;. Reposition the component and left click to drop. The same functionality can be achieved by hovering over the component and by pressing g. r will rotate the component while x and y will flip it about its x- or y-axis.\n  Right-Click  Move or m is also a valuable option for moving anything around, but it is better to use this only for component labels and components yet to be connected. This is because Drag keeps wire connections to the component attached while moving, while Move simply moves the components, leaving the wires behind. Both can be useful, but Drag is more often what you want.\n  Edit the second resistor by hovering over it and pressing v. Replace \u0026lsquo;R\u0026rsquo; with \u0026lsquo;100\u0026rsquo;. You can undo any of your editing actions with Ctrl+Z.\n  Change the grid size. You have probably noticed that on the schematic sheet all components are snapped onto a large pitch grid. You can easily change the size of the grid by Right-Click\r\rGrid.\n  In general, it is recommended to use a grid of 50.0 mils for the schematic sheet.\n  We are going to add a Teensy to our circuit, which does not have a symbol natively in KiCad. Copy teensy.lib into the KiCad project folder. In the Eeschema menu, choose Preferences\r\rManage Symbol Libraries. In the Symbol Libraries window you can see two tabs: Global Libraries and Project Specific Libraries. Each one has one sym-lib-table file. For a library (.lib file) to be available it must be in one of those sym-lib-table files. If you have a library file in your file system and it’s not yet available, you can add it to either one of the sym-lib-table files. We will now add the Teensy library.\n  Select the Project Specific table. Click the Browse Libraries\u0026hellip; button below the table. Since you placed the library in the project folder, you should be able to choose and add the teensy.lib library and close the window. It will be added to the end of of the list. If you wish you can click its nickname and change it, but \u0026lsquo;teensy\u0026rsquo; is fine for now. Close the Symbol Libraries window with OK.\n  Repeat the add-component steps, however this time select the \u0026lsquo;teensy\u0026rsquo; library instead of the \u0026lsquo;Device\u0026rsquo; library and pick the \u0026lsquo;Teensy-LC\u0026rsquo; component.\n  Hover the mouse over the microcontroller component. Notice that x and y again flip the component. Keep the symbol mirrored around the Y axis so that pins 5 and 6 (3_RX1_PWM_Touch and 4_TX1_PWM_Touch) point to the right.\n  Repeat the add-component steps, this time choosing the \u0026lsquo;Device\u0026rsquo; library and picking the \u0026lsquo;LED\u0026rsquo; component from it.\n  Add another component, this time Conn_01x03_Male. This is a generic 3-pin connector.\n  Organise all components on your schematic sheet as shown below.\n  The component identifier \u0026lsquo;J?\u0026rsquo; will appear above the Conn_01x03_Male label. If you want to change its position, right click on \u0026lsquo;J?\u0026rsquo; and click on \u0026lsquo;Move Field\u0026rsquo; (equivalent to m). It might be helpful to zoom in before/while doing this. Reposition \u0026lsquo;J?\u0026rsquo; under the component as shown below. Labels can be moved around as many times as you please.   It is time to place the power and ground symbols. Click on the \u0026lsquo;Place power port\u0026rsquo; button on the right toolbar. Alternatively, press p. In the component selection window, scroll down and select \u0026lsquo;VCC\u0026rsquo; from the \u0026lsquo;power\u0026rsquo; library. Click OK.\n  Click above the pin of the 1\u0026thinsp;k\u0026Omega;\rresistor to place the VCC part. Click on the area above and to the left of the Teensy. In the \u0026lsquo;Component Selection history\u0026rsquo; section select \u0026lsquo;VCC\u0026rsquo; and place another to the left of the microcontroller. Repeat the add process again and place a VCC part above pin 1 of the connector. Move references and values out of the way if needed.\n  Repeat the add power symbol steps but this time select the GND part. Place a GND part under pin 3 of the connector. Place another GND symbol below and to the left of the microcontroller. Your schematic should now look something like this:\n  Next, we will wire all our components. Click on the \u0026lsquo;Place wire\u0026rsquo; icon on the right toolbar.  Be careful not to pick \u0026lsquo;Place bus\u0026rsquo;, which appears directly beneath this button but has thicker lines and is blue. For more on how to use bus connections refer to the full KiCad Documentation.\n Click on the little circle at the end of pin 5 of the microcontroller and then click on the little circle on pin 1 of the LED. Click once when you are drawing the wire to create a corner. You can zoom in while you are placing the connection.  If you want to reposition wired components, it is important to use g (to grab) and not m (to move). Using grab will keep the wires connected.\n Repeat this process and wire up all the other components as shown below. To terminate a wire just double-click. When wiring up the VCC and GND symbols, the wire should touch the bottom of the VCC symbol and the middle top of the GND symbol. See the screenshot below.   We will now consider an alternative way of making a connection using labels. Pick a net labelling tool by clicking on the \u0026lsquo;Place net label\u0026rsquo; icon on the right toolbar. You can also use l.\n  Click the wire connected to the resistor which we connected to pin 6 of the microcontroller. Name this label \u0026lsquo;INPUT\u0026rsquo;. The label is still an independent item which you can for example move, rotate and delete. The small anchor rectangle of the label must be exactly on a wire or a pin for the label to take effect.\n  Follow the same procedure and place another label on the wire to pin 2 of the connector. Also name it \u0026lsquo;INPUT\u0026rsquo;. The two labels, having the same name, create an invisible connection between pin 2 of the connector and the 100\u0026thinsp;\u0026Omega;\rresistor. This is a useful technique when connecting wires in a complex design where drawing the lines would make the whole schematic messier. To place a label you do not necessarily need a wire, you can simply attach the label to a pin.\n  Labels can also be used to simply label wires for informative purposes. Place a label on pin 5 of the Teensy. Enter the name \u0026lsquo;uCtoLED\u0026rsquo;. Name the wire between the resistor and the LED as \u0026lsquo;LEDtoR\u0026rsquo;.\n  You do not have to label the VCC and GND lines because the labels are implied from the power objects they are connected to.\n  Below you can see what the final result should look like.\n   Sometimes it is good to write comments here and there. To add comments on the schematic use the \u0026lsquo;Place text\u0026rsquo; icon on the right toolbar.\n  All components now need to have unique identifiers, so let's rename all of those components still named \u0026lsquo;R?\u0026rsquo; or \u0026lsquo;J?'. Identifier assignation can be done automatically by clicking on the \u0026lsquo;Annotate schematic symbols\u0026rsquo; icon ~annotate symbols icon on the top toolbar.\n  In the Annotate Schematic window, select \u0026lsquo;Use the entire schematic\u0026rsquo; and click on the \u0026lsquo;Annotate\u0026rsquo; button. Click \u0026lsquo;Close\u0026rsquo;. Notice how all the \u0026lsquo;?\u0026rsquo; have been replaced with numbers. Each identifier is now unique. In our example, they have been named \u0026lsquo;R1\u0026rsquo;, \u0026lsquo;R2\u0026rsquo;, \u0026lsquo;U1\u0026rsquo;, \u0026lsquo;D1\u0026rsquo; and \u0026lsquo;J1\u0026rsquo;.\n  If you're just capturing the schematic for documentation purposes, this schematic is now finished. Hit Ctrl+s to save, and you're done! If you want a PDF version, either select \u0026lsquo;Print\u0026rsquo; and print to a pdf printer, or select \u0026lsquo;Plot\u0026rsquo; and set the output format to PDF.\n  Additional steps to run ERC KiCad can also run an electrical rules check (ERC) to catch obvious mistakes; to do this, we need to make some more annotations to tell KiCad what we're doing.\n  First deal with unconnected wires. Any pin or wire that is not connected will generate a warning when checked by KiCad. To avoid these warnings you can either instruct the program that the unconnected wires are deliberate or manually flag each unconnected wire or pin as unconnected.\n  Click on the \u0026lsquo;Place no connection flag\u0026rsquo; icon on the right toolbar. Click on the unconnected pins. An X will appear to signify that the lack of a wire connection is intentional.\n  It is now necessary to add a \u0026lsquo;Power Flag\u0026rsquo; to indicate to KiCad that power comes in from somewhere. Press a and search for \u0026lsquo;PWR_FLAG\u0026rsquo; which is in \u0026lsquo;power\u0026rsquo; library. Place two of them. Connect them to a GND pin and to VCC as shown below.\n  We can now check our schematic for errors. Click on the \u0026lsquo;Perform electrical rules check\u0026rsquo; icon on the top toolbar. Click on the \u0026lsquo;Run\u0026rsquo; button. A report informing you of any errors or warnings such as disconnected wires is generated. You should have 0 Errors and 0 Warnings. In case of errors or warnings, a small green arrow will appear on the schematic in the position where the error or the warning is located. Check \u0026lsquo;Create ERC file report\u0026rsquo; and press the \u0026lsquo;Run\u0026rsquo; button again to receive more information about the errors.  "
},
{
	"uri": "http://spdldaemon.github.io/docs/applicationnotes/magneticfieldsensing/",
	"title": "Magnetic Field Sensing",
	"tags": [],
	"description": "",
	"content": "If this looks overly mathematical, don’t worry, you can certainly skip the math and get something working by trial and error as is commonly done. If you take this approach, you still might want to check out the section on matching your coil resonance to the track frequency to minimize noise picked up from other sources. Either way, it’s usually helpful to understand the underlying physics when it comes to troubleshooting or improving your sensors. Also, some quick, back of the envelope calculations can often get you in the ballpark a lot quicker than random experimentation.\nBasic E\u0026amp;M A current flowing in an infinite wire will generate a magnetic field that circles around the wire (in a direction given by the right hand rule – align your thumb with the current, and your fingers point in the B field direction) whose strength drops off with \\(1/r\\):\n$$B=\\frac{\\mu_0 i}{2\\pi r}$$\nwhere \\(\\mu_0 = 1.26 \\times 10^{-6} \\mathrm{H}/\\mathrm{m}\\) is the vacuum permeability, \\(i\\) is the current in Amps, and \\(r\\) is the distance from the wire in meters.\nSo if there is a sinusoidal current flowing in the wire that looks like\n$$ \\begin{aligned} i \u0026amp;= 0.1 \\sin \\omega t \\\\ \\omega \u0026amp;= 2\\pi f \\\\ f \u0026amp;= 20000 \\end{aligned} $$\nIt will generate a magnetic field around the wire that varies sinusoidally in time:\n$$ B = \\frac{\\mu_0}{2\\pi r} \\cdot 0.1 \\sin \\omega t $$\nDetection An easy way to detect a magnetic field is to take advantage of the fact that when the magnetic flux in a loop of wire changes, a voltage is generated in the coil that is proportional to the rate of change:\n$$ \\begin{aligned} V \u0026amp;= -\\frac{\\partial\\Phi}{\\partial t} \\\\ \\Phi \u0026amp;= B \\cdot A\\end{aligned} $$\nwhere \\(B\\) is the magnetic field, and \\(A\\) is the coil area. We assume that \\(B\\) is constant over the area of the coil, which is a good approximation when the coils are small.\nCalculating the peak induced voltage for a 1\u0026thinsp;cm\rdiameter coil located 10\u0026thinsp;cm\rfrom the wire, we get:\n$$ \\begin{aligned} V \u0026amp;= -\\frac{\\partial}{\\partial t} \\left( \\frac{\\mu_0}{2\\pi r} \\cdot 0.1 \\sin \\omega t \\right) \\cdot A \\\\ \u0026amp;= \\omega \\cdot \\left( \\frac{\\mu_0}{2\\pi r} \\cdot 0.1 \\cos \\omega t \\right) \\cdot A \\\\ V_\\mathrm{peak} \u0026amp;= 2.52 \\thinspace \\mathrm{\\mu V} \\end{aligned} $$\nwhich is a miniscule value, and would not be able to see it on a typical oscilloscope with 5\u0026thinsp;mV\rresolution. To increase your signal, you can connect several of these sensor loops in series. If you have \\(N\\) turns on your coil, you will get an induced voltage that is \\(N\\) times larger than the result for a single loop. With 1000 coils on the same sensor as above, you would see 2.52\u0026thinsp;mV\r, which is something you can work with. This still needs amplification, but a relatively simple op-amp circuit will do.\nSo at some fixed distance from the wire, there are two things you can do to increase your signal—increase coil area or number of turns:\n$$ V \\propto N \\cdot A $$\nCoils as Inductors Any time you have a coil, you also have an inductor. For a coil with length much greater than diameter, the inductance is:\n$$ L = \\frac{\\mu_0 A N^2}{l} $$\nwhere \\(A\\) is the coil area, \\(N\\) the number of turns, and \\(l\\) the length of the coil.\nFor a practical coil that may have a length similar in magnitude to the diameter, this is only an approximation good to within a factor of 2 or so. To increase the inductance, inductors are often wound around core materials. These cores effectively amplify the magnetic field (and therefore inductance), by anywhere from factors of 10s to 1000s. Iron is commonly used at low frequencies, and ferrite is used at higher frequencies.1\nAlso, real inductors always have some capacitance, resulting from the numerous turns of wire wound next to one another. There is always capacitance between two neighboring wires, increasing with decreasing separation.2 This capacitance can easily be on the order of 10s to 100s of pF for a peanut-sized coil.\nYou might think, \u0026lsquo;who cares about picoFarads anyways\u0026rsquo;—that is, until you see a mysterious high frequency ringing on a coil that you thought was an ideal inductor. You may be able to see this with sensors that are not designed to resonate at the track frequency (as described below) but resonate at some other frequency (ie: the “self-resonant” frequency that depends on coil capacitance \u0026amp; inductance). A simple model of what this can look like can be generated in circuitmaker:\nThe sinusoidal source is simulating the signal from the track, the lower magnitude square wave source is simulating quick noise pulses that might be generated from motor switching, etc. The resulting waveforms show hi-frequency ringing at the self-resonant frequency (triggered by the noise spikes) riding on top of the desired 20\u0026thinsp;kHz\rsignal waveform:\nLC Resonance and Signal Amplification You can make a functional sensor using a coil as described above, although it may need to be pretty big (large area, lots of turns) in order to give you a signal large enough to work with. By adding a capacitor in parallel with your coil (and effectively in parallel with the internal coil capacitance), you can make a circuit that resonates at the track frequency. The frequency of this resonance is given by:\n$$ f = \\frac{1}{2\\pi\\sqrt{LC}} $$\nThe effect of this is that a small signal from the track can drive a much larger oscillation in the parallel inductor capacitor circuit, which is easier to detect. The effective amplification of a circuit like this can easily be on the order of 10-100. You can model the induced voltage in the coil as a sinusoidal voltage source in series with the inductor:3\nIf you could build this circuit and then swept the frequency knob on the function generator, you’d get a plot of \\(V_\\mathrm{in}/V_\\mathrm{out}\\) vs. frequency that looks like:\nIf you actually used ideal components4 and turned the knob very slowly, you’d find that the peak at 20\u0026thinsp;kHz\rwas infinite.\nThis measure of the sharpness of resonance is called the quality factor, or Q, of the circuit. For this circuit, it is infinite. Q is defined as the resonant frequency divided by the width in frequency units of the curve at the point where it is \\(1/\\sqrt{2}=0.707\\) times the maximum value.5\nSuppose all the ideal inductors are used up and you have to order a real inductor from Digi-Key. You find that it has 26\u0026thinsp;\u0026Omega;\rof resistance due to the many turns of thin wire. You plug this into your circuitmaker model:\nand get this response:\nNow instead of having an infinite peak, the resonant circuit amplifies the field signal by about 40. Since the peak is no longer infinite, you happily calculate Q to be 40. Another handy Q formula for a series resistor like this is:\n$$ Q = \\frac{2\\pi\\omega_\\mathrm{res} L}{R} $$\nNow, suppose Mark Merlo was playing with the function generator and tweaked the frequency knob so it’s generating 21\u0026thinsp;kHz\rinstead of 20\u0026thinsp;kHz\r. Now the gain of the resonant circuit goes from 40 down to 9, just after you spent hours calibrating your code to work with a gain of 40. So that’s problem #1: your circuit is sensitive to small changes in track frequency. Eventually, Sara figures out what the deal is and recalibrates the knob to 20.0001\u0026thinsp;kHz\r. Luis is just starting to build his circuit but Brandon stole all of his capacitors to extend the range of the electric banana. Fortunately, he manages to find a pair with the exact value he needs in the cabinet of freedom, and they even have a ±\r5\u0026thinsp;%\rtolerance (good as far as capacitors go). Suppose one of the caps is dead on the labeled value, and the other is 5\u0026thinsp;%\rhigh, so that circuit will have a resonant frequency of 19.5\u0026thinsp;kHz\r. Now the gain will be approximately 17 for that sensor and 40 for the other sensor—not a very well matched pair of sensors.\nThese undesirable effects of a sharp resonance peak can mitigated by lowering the Q even more, which flattens out the peak. An easy way to do this is with a parallel resistor:\nIf you only have a parallel capacitor (in the location of the 10\u0026thinsp;k\u0026Omega;\rresistor) and replace the 26\u0026thinsp;\u0026Omega;\rcapacitor with a wire, the Q is given by:6\n$$ Q = 2\\pi f_\\mathrm{res} RC $$\nwhere \\(C\\) is the total capacitance summing the coil and external capacitances.\nIf you have both resistors in the circuit, the resultant Q is well approximated by $$ \\frac{1}{Q_\\mathrm{total}} = \\frac{1}{Q_\\mathrm{R,series}} + \\frac{1}{Q_\\mathrm{R,parallel}} $$\nThis expression may even be exact, who knows? Anyways, the peak is quite a bit flatter now so that if the frequency shifts by 1\u0026thinsp;kHz\rto 21\u0026thinsp;kHz\r, the signal only changes by 20\u0026thinsp;%\r, which is a lot better than the factor of 4 we saw above.\nThis parallel resistor that lowers the Q of the circuit is sometimes called a Q-killer resistor for obvious reasons. You’ll want to pick a Q-killer resistor that gives you good amplification without too sharp of a resonant peak which would result in sensitivity to slight frequency variations.\nNoise Rejection If there is EM noise at frequencies other than the track frequency,7 it will also generate a signal in your sensors. Suppose you have a coil without a resonant capacitor, and the rate of change of magnetic flux from the switched motor current is the same as the rate of change of magnetic flux due to the wire under the track, in the location of your sensor. Then an equal voltage will be produced in the sensor, which will show up as noise that is just as large as your signal. If your sensor is part of a tuned circuit that amplifies the track frequency by a factor of 10, then the induced noise from the motor will be 1/10 of the track signal, which is a good thing.\nThere are a few things you can do to minimize magnetic noise generated by the motor.\n  Don’t put your sensors right next to your motors.\n  Run the current supply and return wires for a motor close together. If you run them in a big open loop (and maybe wrap them around your sensors a few times), they will generate much larger magnetic fields \u0026amp; hence more sensor noise.\n  Don’t switch motor currents faster than you need to. For the LMD18200’s, this means leaving off the bootstrap capacitors (which (when added) cause the MOSFETs in the H-bridge to turn on and off a lot faster). When you turn off a MOSFET real fast, the current through it and all the associated wiring changes real fast (large di/dt). This causes any associated magnetic fields to change real fast (which is what your sensors detect), and also causes voltage drops across the wires that were supplying the current due to the inductance of these supply wires.\n  Decreasing switching speed is entirely different from decreasing PWM frequency—lowering the PWM frequency will not affect the switching speed. The MOSFETs still switch on/off at the same speed, they just switch less often at a lower PWM frequency.\n Signal Amplification After all this work (actually, its not that bad, just a few components soldered in parallel), you’ll still probably want to amplify your signal. One feature of the resonant circuits described above is that they do not have very high output impedance—that is, if you try drawing significant currents from them it will load them down and kill the resonance. Kind of like sticking a tuning fork in a block of cheese—the fork will not continue to shake the cheese at 1 kHz for minutes. Instead, the vibrations will quickly die down to nothing.\nTwo ways to deal with this low-impedance sensor are to buffer the signal or simply use a non-inverting op-amp configuation (as shown below):\nAs long as the op amp doesn’t saturate (output goes to one rail or the other), this will work pretty well. The LM6144s have the \u0026lsquo;\u0026lsquo;interesting\u0026rsquo;\u0026rsquo; property that if an output saturates and the inputs are no longer held at the same voltage (no longer ideal \r), then the input impedance drops drastically, which can load the sensor down and kill the resonance. This can make for some frustrating debugging sessions until you figure out what’s happening.\nOnce you’ve amplified the signal, you can either build a peak detector circuit or do the peak detection in software. Given the amount of other stuff going on in software, the peak detector circuit is not a bad choice. Choose your R \u0026amp; C carefully to give the best compromise between smooth signal and fast response to signal changes:\nTime constant, \\(\\tau=RC\\), too small (excessive ripple):\nTime constant, \\(\\tau=RC\\), too large (output doesn't track input):\nSensor Locations \u0026amp; Sensor Signal Math Once you’ve got your sensors working, where do you put them and what do you do with them? First of all, there are three basic sensor orientations. We’ll call these the Horizontal, Vertical, and Parallel (referring to the axis of the coil). When your sensor axis is parallel with the wire, the field is all perpendicular to the coil, so there is no field component going through the coil, and you get no signal. So, you can forget about those. Vertical and Horizontal coils are more useful.\nFor a coil that is located a horizontal distance \\(x\\) from the wire and a height \\(h\\) above the wire, the magnitude of the component of the field that is actually passing through the coil (aligned with the coil axis) is given by:\n$$ \\begin{aligned} B_\\mathrm{h} \u0026amp;= \\frac{\\mu_0 i h}{2\\pi\\left(x^2+h^2\\right)} \\quad \\mathrm{horizontal\\space{}coil} \\\\ B_\\mathrm{v} \u0026amp;= \\frac{\\mu_0 i x}{2\\pi\\left(x^2+h^2\\right)} \\quad \\mathrm{vertical\\space{}coil} \\end{aligned} $$\nFor a horizontal sensor at fixed height \\(h_0\\), if you plot the normalized signal in the sensor over a range of \\(x\\) values that span \\(\\pm3h_0\\) you will get something looking like:\nSuppose you have two sensors, each mounted a distance \\(h_0\\) from the center of the robot. Assume horizontal distance \\(x\\) increases positively to the right of the wire. For a sensor mounted at \\(x = +h_0\\), the sensor will be over the wire when the center of the robot is at \\(x = -h_0\\), so plotting the right sensor signal as a function of the position of the robot center gives us something like:\nThe left sensor signal is found in exactly the same way, and its peak will occur when the center of the robot is at \\(x = +h_0\\). If you read these signals into the HC12 and subtract them in software (Left Sensor – Right Sensor), you get a signal which is roughly proportional to the deviation of the robot center from the wire, over a limited range centered about a deviation of 0.\nIf you use the summed signal for feedback control, be aware that if the wire is not between the sensors, the sense of the signal can invert. For example, going from \\(x=-1\\) to \\(x=0\\), the value of the summed signal is increasing. However, this is also true when going from \\(x=-2\\) to \\(x=-3\\)—away from the wire. Keep this in mind when deciding how your robot will respond.\n You can follow the exact same procedure to make plots of vertically mounted sensors, or different horizontal sensor configurations (heights, spacing). Similarly, by manipulating your sensor signals with simple math, you may find some resultant signal that works better for whatever you want to do with the position information.\nOther Sensing Tidbits   If your sensors are mounted near any conductive materials (aluminum and copper in particular), induced currents will flow in the metals that partially cancel out the fields that you are trying to measure. So mounting your sensors on aluminum rails probably would not be a good idea.\n  You’ll have to have a fairly accurate capacitance to set the resonant frequency where you want it. There are 5\u0026thinsp;%\rand 10\u0026thinsp;%\rtolerance polyester caps for sale with the coil/inductors. Two advantages of these caps over ceramic caps is tolerance (\r20\u0026thinsp;%\ris typical on ceramic) and low capacitance change with change in temperature (not sure what the specs are but these type of capacitors typically change an order of magnitude less than ceramic caps for a given change in temperature).\n  If you’re trying to dial in your total capacitance by adding small parallel capacitors, the tolerances on these smaller caps are much less important than the tolerances on the larger caps that make up the bulk of the capacitance. For example, if a parallel cap provides the final 10\u0026thinsp;%\rof capacitance with a 10\u0026thinsp;%\rcapacitance tolerance, it will only contribute about 1\u0026thinsp;%\rto the overall tolerance range.\n   Contributed by Oliver Max, 20 Feb 2002.\nAdapted for web by Arul Suresh, 11 January 2020.\n  Ferrite has much lower losses at high freq. since it is an electrical insulator and doesn’t let internal dissipative eddy currents flow as iron does. \u0026#x21a9;\u0026#xfe0e;\n For two wires with radius \\(r\\) and separation \\(s\\), the capacitance is \\(C=\\pi\\epsilon/\\log\\left(s/r\\right)\\)where \\(\\epsilon\\) is the permittivity of the insulator, typically 2-6 times \\(\\epsilon_0\\), the permittivity of free space. \u0026#x21a9;\u0026#xfe0e;\n In this model, you have access to the outer leads of the sinusoidal source and inductor in your real-world inductor, but not the one connecting the two. \u0026#x21a9;\u0026#xfe0e;\n Available in the TA office for a slight premium. \u0026#x21a9;\u0026#xfe0e;\n That is, \\(\\infty/0\\) for this curve, which as we all know is \u0026ldquo;a suffusion of yellow\u0026rdquo; in your calculator. \u0026#x21a9;\u0026#xfe0e;\n Currently just copied, and this sentence clearly got jumbled at some point. \u0026#x21a9;\u0026#xfe0e;\n For example, from the switching of motor currents. \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "http://spdldaemon.github.io/docs/tools/",
	"title": "Tools",
	"tags": [],
	"description": "",
	"content": "Tools Tutorials, Tips, and Tricks for the various software and hardware tools you might encounter in lab.\n"
},
{
	"uri": "http://spdldaemon.github.io/docs/tools/kicad/",
	"title": "KiCad",
	"tags": [],
	"description": "",
	"content": "KiCad1 is an open-source software tool for the creation of electronic schematic diagrams and PCB artwork. Although essentially treated as one program, KiCad is really more of a tight grouping of the following stand-alone software tools:\n   Program name Description File extension     KiCad Project manager *.pro   Eeschema Schematic and component editor *.sch, *.lib, *.net   Pcbnew Circuit board and footprint editor *.kicad_pcb, *.kicad_mod   GerbView Gerber and drill file viewer *.g*, *.drl, etc.   Bitmap2Component Convert bitmap images to components or footprints *.lib, *.kicad_mod, *.kicad_wks   PCB Calculator Calculator for components, track width, electrical spacing, color codes, and more\u0026hellip; None   Pl Editor Page layout editor *.kicad_wks    The file extension list is not complete and only contains a subset of the files that KiCad supports. It is useful for the basic understanding of which files are used for each KiCad application. KiCad is mature open-source software, and is robust enough for typical use in lab as well as for more involved, complex electronic board designs.\n  KiCad basic window. The icon row from left to right corresponds to Eeschema (schematic and component editors), Pcbnew ( board and footprint editors), GerbView, Bitmap2Component, PCB Calculator, and Pl Editor.\n  This tutorial is written using KiCad 5.0.0 on Windows 10. While significant changes are unlikely, be aware that small details may change if your install is different.\n KiCad does not present any board-size limitation and it can easily handle up to 32 copper layers, up to 14 technical layers and up to 4 auxiliary layers. KiCad can create all the files necessary for building printed boards, Gerber files for photo-plotters, drilling files, component location files and a lot more. KiCad also incorporates ngspice, an open-source circuit simulator.\nBeing open source (GPL licensed), KiCad represents the ideal tool for projects oriented towards the creation of electronic hardware with an open-source flavour.\nOn the Internet, the homepage of KiCad is: http://www.kicad-pcb.org/\nDownloading and installing KiCad KiCad runs on GNU/Linux, Apple macOS and Windows. You can find the most up to date instructions and download links at:\nhttp://www.kicad-pcb.org/download/\nUnder Apple macOS Stable builds of KiCad for macOS can be found at: http://downloads.kicad-pcb.org/osx/stable/\nUnder Windows Stable builds of KiCad for Windows can be found at: http://downloads.kicad-pcb.org/windows/stable/\nUnder GNU/Linux   Show Unix Installation Details   Stable releases of KiCad can be found in most distribution’s package managers as kicad and kicad-doc. If your distribution does not provide latest stable version, please follow the instruction for unstable builds and select and install the latest stable version.\nUnder Ubuntu, the easiest way to install an unstable nightly build of KiCad is via PPA and Aptitude. Type the following into your Terminal:\nsudo add-apt-repository ppa:js-reynaud/ppa-kicad sudo aptitude update \u0026amp;\u0026amp; sudo aptitude safe-upgrade sudo aptitude install kicad kicad-doc-en Under Debian, the easiest way to install backports build of KiCad is:\n# Set up Debian Backports echo -e \u0026#34; # stretch-backports deb http://ftp.us.debian.org/debian/ stretch-backports main contrib non-free deb-src http://ftp.us.debian.org/debian/ stretch-backports main contrib non-free \u0026#34; | sudo tee -a /etc/apt/sources.list \u0026gt; /dev/null # Run an Update \u0026amp; Install KiCad sudo apt-get update sudo apt-get install -t stretch-backports kicad Under Fedora the easiest way to install an unstable nightly build is via copr. To install KiCad via copr type the following in to copr:\nsudo dnf copr enable @kicad/kicad sudo dnf install kicad Alternatively, you can download and install a pre-compiled version of KiCad, or directly download the source code, compile and install KiCad.\n  KiCad Workflow Despite its similarities with other PCB design software, KiCad is characterised by a unique workflow in which schematic components and footprints are separate. Only after creating a schematic are footprints assigned to the components.\nOverview The KiCad workflow is comprised of two main tasks: drawing the schematic and laying out the board. Both a schematic component library and a PCB footprint library are necessary for these two tasks. KiCad includes many components and footprints, and also has the tools to create new ones.\nInitially, the process begins with schematic capture, as in any other tool. After the schematic has been defined, footprints are attached to each symbol on the schematic, and the information is then used to lay out the board.\nThe KiCad Tutorial has a detailed flowchart of the full board design process.\n Some Notes on Fabrication Both Oshpark (PCB only) and MacroFab(PCB + assembly) directly accept KiCad formats for fabrication. Naturally neither is the cheapest possible service, but for small projects the convenience can be an advantage.\n Adapted in part from the KiCad Getting Started Tutorial, CC-BY-3.0  .\n  Pronounced \u0026lsquo;Key-CAD\u0026rsquo;. \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "http://spdldaemon.github.io/docs/applicationnotes/",
	"title": "Application Notes",
	"tags": [],
	"description": "",
	"content": "Application Notes SPDL-curated approaches to solving common problems.\n"
},
{
	"uri": "http://spdldaemon.github.io/docs/datasheets/",
	"title": "Datasheets",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://spdldaemon.github.io/docs/",
	"title": "The SPDL Docs Repository",
	"tags": [],
	"description": "",
	"content": "The SPDL Docs Repository Welcome to the SPDL Docs Repository!\nThis is a work in progress, and is intended to eventually serve as a repository for SPDL-curated best practices, tools, and tips.\nIf you feel extra motivated to write a whitepaper on a topic, you can clone the Github repository, add the page, and make a pull request for SPDL Daemon to review. In this case, you may find the linked documentation at the lower left to be helpful when adding your page. This site is built using Hugo, with the Learn theme.\n"
},
{
	"uri": "http://spdldaemon.github.io/docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://spdldaemon.github.io/docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]